---
layout: post
title: kmp
categories: algorithm
tags: kmp algorithm
---

A串中是否包含B串
  
>前缀和后缀：  
>next数组的求法：  
>采用递推的方式  
>根据定义`next[0]=-1`，假设`next[j]=k`, 即`P[0...k-1]==P[j-k,j-1]`  
1)若`P[j]==P[k]`，则有`P[0..k]==P[j-k,j]`，很显然，`next[j+1]=next[j]+1=k+1`;  
2)若`P[j]!=P[k]`，则可以把其看做模式匹配的问题，即匹配失败的时候，k值如何移动，显然`k=next[k]`。
 
	void getNext(char *p,int *next)
	{
	    int j,k;
	    next[0]=-1;
	    j=0;
	    k=-1;
	    while(j<strlen(p)-1)
	    {
	        if(k==-1||p[j]==p[k])    //匹配的情况下,p[j]==p[k]
	        {
	            j++;
	            k++;
	            next[j]=k;
	        }
	        else                   //p[j]!=p[k]
	            k=next[k];
	    }
	}
	 
	int KMPMatch(char *s,char *p)
	{
	    int next[100];
	    int i,j;
	    i=0;
	    j=0;
	    getNext(p,next);
	    while(i<strlen(s))
	    {
	        if(j==-1||s[i]==p[j])
	        {
	            i++;
	            j++;
	        }
	        else
	        {
	            j=next[j];       //消除了指针i的回溯
	        }
	        if(j==strlen(p))
	            return i-strlen(p);
	    }
	    return -1;
	}

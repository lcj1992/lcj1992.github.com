---
layout: post
title: 工厂（简单工厂、工厂方法、抽象工厂）
categories: clean_code
tags: factory
---

* TOC
{:toc}

## 简单工厂（静态工厂）

`创建对象，而不向客户端暴露实例化细节`

### 示例

1. BeanFactory#getBean()： IMeituanSmsService
2. Integer#valueOf()
3. Proxy#newProxyInstance()
4. CommonResponse#buildSuccess()
5. java.sql.DriverManager#getDriver()
6. CreateOrderServiceFactory#getCreateOrderService()
7. AllItemsPriceCheckLogic#createErrorResult()

### 优点

1. 有名字，根据方法的意图来命名，可读性强。Lists#newArrayList() Lists#newLinkedList()
2. 对象可复用 Integer#valueOf(), Boolean#valueOf()
3. 创建参数化实例时，代码更简洁 Maps#newHashMap()
4. 可以返回更抽象的类型
5. 低耦合，将创建对象的职责和使用对象的职责中分开，客户端不需要知道具体的产品类，只需要关心所需产品对应的工厂

### 使用场景

1. 

## 工厂方法

`定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。`

简单工厂封装了变化，但是当变化发生时，还是需要修改代码

### 类图

![类图](/images/design_pattern/factory.png)

1. IProduct: 定义工厂方法所创建对象的接口
2. 实现Product接口
3. 声明工厂方法，返回一个Product类型对象，也可以定义一个工厂方法的缺省实现；可以调用工厂方法以创建一个Product对象
4. 重定义工厂方法，返回一个ConcreteProduct实例

### 优点

1. 简单工厂的优点
2. 扩展性高，扩展遵从开闭原则，新增产品通过添加产品类和对应产品的工厂类来实现，不需要修改原有代码
3. 遵从依赖倒置原则

[代码举例](https://github.com/lcj1992/learn/blob/master/java/designPattern/src/main/java/creational/facotry/FactoryTest.java)

### 使用场景

todo

## 抽象工厂

![产品族](/images/Design_pattern/abstract_factory.jpg)
动机： 产品 -> 产品族, 工厂 -> 抽象工厂

定义： 提供一个创建一系列相关或者相互依赖对象的接口，而无需指定它们具体的类。

### 类图

![类图](/images/design_pattern/abstract_factory.png)

1. Factory: 声明创建抽象产品对象的操作接口
2. ConcreteFactory: 实现创建具体产品对象的操作
3. AbstractProduct: 为一类产品对象声明一个接口
4. ConcreteProduct: 定义一个被具体工厂创建的产品对象；实现AbstractProduct接口

### 优点

1. 有利于产品的一致性
2. 开闭原则：
    * 遵从：添加新的产品组合时，新增对应的工厂类即可。
    * 违反：添加新的产品时，所有的工厂类都需要添加对应的创建方法


## 参考

[工厂方法](https://en.wikipedia.org/wiki/Factory_method_pattern)

[抽象工厂](https://en.wikipedia.org/wiki/Abstract_factory_pattern)

[创建对象与使用对象——谈谈工厂的作用](http://blog.csdn.net/lovelion/article/details/7523392)

---
layout: post
title: 实现模式
categories: clean_code
tags: clean_code
---

* TOC
{:toc}

### 概述

这是一本小书，也是一个好书。

"我惊讶的发现，尽管能够快捷流畅地做出各种编程中的决定，但我没法解释自己为什么如此确定诸如“这个方法为什么应该被这样调用”，或者“那块代码为什么属于那个对象”之类的事情"。这本书在我看来就是解释这些个东西的。

这本书《实现模式》最大的跨度只到类一级，与之相比，设计模式则主要是在讨论类与类之间的关系，"本书的深度应该介于Design patterns和java语言手册之间"。

全书分为7大块，如下图所示

![实现模式](/images/design_pattern/implement-pattern-overview.png)

第一块，总体介绍，几个简短的章节描述了“用代码进行沟通”的重要性和价值所在，以及实现模式背后的思想。自认为是最重要的一块。沟通、简单和灵活这三条价值观为模式提供了广泛的动机。局部化影响、最小化重复、将逻辑和数据捆绑、对称性（匀称性）、声明式表达和变化率这6条原则帮助我们将价值观转化为实际行动，然后开始介绍各种模式。

第二块，类，这部分讲述了为什么要创建类，如何创建类，如何用类来书写逻辑等问题

第三块，状态，关于状态的存取的模式

第四块，行为,这部分模式告诉阅读者如何用代码来编写逻辑，特别是如何用多种不同的方式来做这件事

第五块，方法，关于如何编写方法的模式，他们将告诉你，根据你对方法的分解和命名，阅读者会作出怎样的判断。

第六块和第七块没怎么看，不说了。

这篇文章是这本书的读后感，要求2，3，4，5这几个模块的每个模式尽量都要**落实到工作中所接触到的例子，真真切切感受其好处**。

### 总体介绍

#### 价值观

沟通、简单、灵活

更多的时候，程序是在被阅读而不是被编写。使用模式可以帮助程序员用更合理的方法来解决常见问题，从而把更多时间、精力和创造力留下来解决真正独一无二的问题。

模式描述了要做什么，价值观提供了动机，原则把动机转化成了实际行动。

#### 原则

1. 局部化影响

    组织代码结构时，保证变化只会产生局部化影响，减少变化所引起的代价。

2. 最小化重复

    * DRY，重复代码，
    * 并行的类层次结构。如果修改一处概念，需要修改两个或者更多的类层次结构就标识变化的影响已经扩散了。

3. 将逻辑和数据捆绑
 
    在发生变化是，逻辑和数据很可能会同时被改动，如果把他们放在一起，那么修改他们所造成的影响就会只停留在局部。

4. 对称性

    * 抽象层次要统一
    * 方法名尽量以方法意图来命名

5. 声明式表达

    不太明白作者说的是什么,todo吧。
 
6. 变化率

    * 把具有相同变化率的逻辑和数据放在一起。
    * 变化率同样适用于数据，一个对象中所有成员变量的变化率应该差不多是相同的。
        * 只会在一个方法的生命周期内修改的成员变量应该是局部变量。
        * 两个同时变化，但又和其他成员的变化步调不一致的变量可能应该属于某个辅助对象。
    * 变化率也是对称性的一个应用，不过是时间上的对称。

#### 动机

    Cost(total) = Cost(develop) + Cost(maintain)
    Cost(maintain) = Cost(understand) + Cost(change) + Cost(test) + Cost(deploy)

软件成本可以被分解为初始成本Cost(develop)和维护成本Cost(maintain),而维护成本往往是大头。

在维护时注重程序员之间的沟通，减少理解代码所带来的代价，清晰明确的代码会带来即时收益:代码缺陷更少，更易共享，开发曲线更加平滑。

### 类
   
#### 类

1. 数据的变化比逻辑的变化要频繁的多。

2. 每个类其实就是这样一个声明：这些逻辑应该放在一起，它们的变化不像它们所操作的数据那么频繁，这些数据也应该放在一起，它们变化的频率差不多，并且由与之关联的逻辑来负责处理。

3. 子类传递的信息应该是：我和超类很像，只有少许差异。子类不要覆盖超类的方法。

4. 用类名来讲述代码的故事。

#### 简单的超类名

1. 类名要简短而有表现力，贴切的命名能引发连锁反应，带来更深入的简化和改进。“哦，我明白了，不就是个scheduler么！”

2. 对于重要的类，尽量用一个单词来为它命名

#### 限定性的子类名

1. 子类的名字有两重职责 PayConfirmEventListener EventListener
   
   * 描述它像什么类
   * 还要说明它们之间的区别。
   * 重要性不及继承体系根上的超类或接口,值得牺牲简明来换取更好的表现力，通常在超类名的基础上扩展一两个词

2. 子类也可以拥有一个简单的名字 List Collection

   * 继承只是用作共享实现的机制，并且子类本身就代表了一个重要的概念，那么这样的子类就应该被视为它自己继承体系的根，拥有一个简单的名字

#### 抽象接口
   
1. 应该在确认无疑地需要灵活性时，才应该引入这种灵活性。

2. java有两种方式来表现抽象接口：超类和interface，他们在应对变化时的涉及的成本各有不同。

##### interface

1. 接口的语义：这是我要完成的任务，除此之外的细节不归我操心。更多的反应的是一种能力。

2. 对接口的改变是不被鼓励的。特别是已经有很多的实现方了，改动接口的成本难以估量。

3. 接口的命名
   
   * 如果把interface看做"没有实现的类"，那么就应该像类名一样地给它们命名（简单的超类名，限定性的子类名）
   * 如果具体类的命名对于交流更重要，这种情况下，可以给interface的名字上加上“I”前缀

##### 抽象类

1. java的interface对接口本身的变化支持不佳，一旦改变了interface，所有的实现类都必须同时修改。

2. 抽象类的局限体现在实现类必须对其忠心不二，如果需要以另一视角来看待同一个实现类，就只能让它实现interface了。

3. interface和类继承体系不是互斥的，你可以提供一个接口说“”你可以使用这些功能，再提供一个超类说“这是一种实现方式”。模板方法

##### 有版本的interface  todo 给个例子

1. 和所有设计决策一样，interface还是有可能变化的，如果真遇到需要对interface进行扩展的尴尬局面，可以引入有版本的interface。

#### 值对象 todo 给个项目中的例子

1. 值对象的所有状态都应该在构造器中设置，其他地方不提供改变其内部状态的方式。对于值对象的操作总是返回新的对象，操作的发起者要自己保存返回的对象。

   * 类声明为final的
   * 类中所有属性为final的

2. 会创建临时对象，但考虑整体成本，这种反对意见往往靠不住脚。

3. 组合使用状态可以变的对象和数值一样不可变的对象，能够最好的表现你的程序。

#### 特化

1. 相同的逻辑处理不同的数据, 不同的逻辑处理相同的数据

##### 子类

1. 多用组合，少用继承

2. 缺点 

   * 如果发现父类中一些变化不太适用于子类，就需要先花点功夫把代码从继承关系中解开。
   * 使用者必须先理解超类，然后才能理解子类
   * 对超类的修改颇有风险，因为子类有可能依赖超类中某个微妙的属性
   * 禁止过深的继承体系。
   * 慎重考虑平行的继承体系，是否真的可以平行。
   * 不能表现不断变化的逻辑，所表现的变化在创建对象时就已经清楚了。

##### 实现器

1. 面向接口编程。

#### 内部类*

1. 内部类被实例化时，它的对象会悄悄地获得创建它的那个对象。如果想访问后者的实例数据而有不想在两者之间建立显式的关联，这个特点就显得很方便了。

2. 内部类并没有真正的构造函数，即使声明一个也没用。

3. 将内部类声明为static，将内部类与其所处的对象完全分离


#### 实例特有的行为

一旦各个实例有不同的行为，就需要在运行时观察或者分析数据流才能理解一个对象的行为。为了让代码容易被读懂，即便是实例特有的行为，也最好在对象实例创建之初就确定下来，以后不再改变。？？？？？？todo 举个会改变的例子

##### 条件语句

1. if-else和switch是最简单的方式。

2. 除了修改对象本身的代码之外，没有其他办法来修改它的逻辑。

3. 条件语句的好处在于简单和局部化。

4. 条件语句的增加会降低可靠性。

eg: 简单工厂，通过条件找对应的产品类。不同策略走不同的代码逻辑等等（简单的可以，复杂的最好用策略模式替代之）

##### 委派

1. 要让不同的实例执行不同的逻辑，另一种办法就是把部分工作委派给不同类型的对象；不变的逻辑放在发起委派的类中，变化的逻辑交给委派的对象。

2. 发起委派常用的技巧： 把发起委派的对象作为参数传递给接受委派的方法（不一定哟）

##### 可拔插的选择器

看不太懂 todo

#### 匿名内部类

1. 只在一处使用，api极其简单

eg. Runnable的run方法,Compartor的compare方法

#### 库类

1. 某些功能放在哪些对象中都不合适，可以弄一个空类，在其中创造静态方法，任何人都不应该创建这个类的实例，它只用来安放这些功能

2. 不适合大量使用，把所有逻辑都放在静态方法中就错过了使用对象的最大好处，把数据放入私有命名空间以便简化逻辑，应该尽量把库类变成合格的对象

eg. DateUtils

### 状态

对象包装了行为和状态，前者被暴露给外部世界，后者则为前者提供支持。对象的好处之一便是将程序中所有的状态分割成小块。没一块都有属于自己的计算环境。

#### 状态

1. 函数式编程语言根本不允许改变状态

2. 把系统的状态细分到各个小块中，每个小块的访问都是受到严格限制，从而可以避免状态“在背后偷偷改变”的问题。

3. 有效管理状态的关键在于，把相似的状态放在一起，确保不同的状态彼此分离。对应前边提到的**变化率**的概念

   * 它们在同一个计算中被用到
   * 它们出现和消亡的时间相同

#### 访问

“访问存储值”和“执行计算”，访问内存状态相当于调用一个函数，后者返回当前存储的值，调用函数相当于读取一个内存位置，并对其中的内容进行计算。但不管怎么说，我们的编程语言确实对两者做了区分，因此我们需要清晰的表述它们之间的差异

##### 直接访问

1. 只在访问器方法，构造器中使用直接存储，只在类及其子类，类所在的包的内部使用直接存储。

##### 间接访问

1. 除上条的使用者，其他的使用者必须间接访问。

2. 如果一个对象的某个状态的大部分访问都来自该对象之外，这就说明还有设计问题隐藏在更深的地方。


### 参考

[实现模式中的“对称性”](http://blog.csdn.net/sharonmei1219/article/details/7406992)

[声明式编程和命令式编程的比较](http://kb.cnblogs.com/page/181030/)

[命令式和声明式，哪个才是你的菜？](http://www.primeton.com/read.php?id=2318&his=1)

---
layout: post
title: 实现模式
categories: clean_code
tags: clean_code
---

* TOC
{:toc}

### 概述

这是一本小书，也是一个好书。

"我惊讶的发现，尽管能够快捷流畅地做出各种编程中的决定，但我没法解释自己为什么如此确定诸如“这个方法为什么应该被这样调用”，或者“那块代码为什么属于那个对象”之类的事情"。这本书在我看来就是解释这些个东西的。

这本书《实现模式》最大的跨度只到类一级，与之相比，设计模式则主要是在讨论类与类之间的关系，"本书的深度应该介于Design patterns和java语言手册之间"。

全书分为7大块，如下图所示

![实现模式](/images/design_pattern/implement-pattern-overview.png)

第一块，总体介绍，几个简短的章节描述了“用代码进行沟通”的重要性和价值所在，以及实现模式背后的思想。自认为是最重要的一块。沟通、简单和灵活这三条价值观为模式提供了广泛的动机。局部化影响、最小化重复、将逻辑和数据捆绑、对称性（匀称性）、声明式表达和变化率这6条原则帮助我们将价值观转化为实际行动，然后开始介绍各种模式。

第二块，类，这部分讲述了为什么要创建类，如何创建类，如何用类来书写逻辑等问题

第三块，状态，关于状态的存取的模式

第四块，行为,这部分模式告诉阅读者如何用代码来编写逻辑，特别是如何用多种不同的方式来做这件事

第五块，方法，关于如何编写方法的模式，他们将告诉你，根据你对方法的分解和命名，阅读者会作出怎样的判断。

第六块和第七块没怎么看，不说了。

这篇文章是这本书的读后感，要求2，3，4，5这几个模块的每个模式尽量都要**落实到工作中所接触到的例子，真真切切感受其好处**。

### 总体介绍

#### 价值观

沟通、简单、灵活

更多的时候，程序是在被阅读而不是被编写。使用模式可以帮助程序员用更合理的方法来解决常见问题，从而把更多时间、精力和创造力留下来解决真正独一无二的问题。

模式描述了要做什么，价值观提供了动机，原则把动机转化成了实际行动。

#### 原则

1. 局部化影响

    组织代码结构时，保证变化只会产生局部化影响，减少变化所引起的代价。

2. 最小化重复

    * DRY，重复代码，
    * 并行的类层次结构。如果修改一处概念，需要修改两个或者更多的类层次结构就标识变化的影响已经扩散了。

3. 将逻辑和数据捆绑
 
    在发生变化是，逻辑和数据很可能会同时被改动，如果把他们放在一起，那么修改他们所造成的影响就会只停留在局部。

4. 对称性

    * 抽象层次要统一
    * 方法名尽量以方法意图来命名

5. 声明式表达

    不太明白作者说的是什么,todo吧。
 
6. 变化率

    * 把具有相同变化率的逻辑和数据放在一起。
    * 变化率同样适用于数据，一个对象中所有成员变量的变化率应该差不多是相同的。
        * 只会在一个方法的生命周期内修改的成员变量应该是局部变量。
        * 两个同时变化，但又和其他成员的变化步调不一致的变量可能应该属于某个辅助对象。
    * 变化率也是对称性的一个应用，不过是时间上的对称。

#### 动机

    Cost(total) = Cost(develop) + Cost(maintain)
    Cost(maintain) = Cost(understand) + Cost(change) + Cost(test) + Cost(deploy)

软件成本可以被分解为初始成本Cost(develop)和维护成本Cost(maintain),而维护成本往往是大头。

在维护时注重程序员之间的沟通，减少理解代码所带来的代价，清晰明确的代码会带来即时收益:代码缺陷更少，更易共享，开发曲线更加平滑。

### 类
   
#### 类

1. 数据的变化比逻辑的变化要频繁的多。

2. 每个类其实就是这样一个声明：这些逻辑应该放在一起，它们的变化不像它们所操作的数据那么频繁，这些数据也应该放在一起，它们变化的频率差不多，并且由与之关联的逻辑来负责处理。

3. 子类传递的信息应该是：我和超类很像，只有少许差异。子类不要覆盖超类的方法。

4. 用类名来讲述代码的故事。

#### 简单的超类名

1. 类名要简短而有表现力，贴切的命名能引发连锁反应，带来更深入的简化和改进。“哦，我明白了，不就是个scheduler么！”

2. 对于重要的类，尽量用一个单词来为它命名

#### 限定性的子类名

1. 子类的名字有两重职责 PayConfirmEventListener implement EventListener
   
   * 描述它像什么类
   * 还要说明它们之间的区别。
   * 重要性不及继承体系根上的超类或接口,值得牺牲简明来换取更好的表现力，通常在超类名的基础上扩展一两个词

2. 子类也可以拥有一个简单的名字 List Collection

   * 继承只是用作共享实现的机制，并且子类本身就代表了一个重要的概念，那么这样的子类就应该被视为它自己继承体系的根，拥有一个简单的名字

### 参考

[实现模式中的“对称性”](http://blog.csdn.net/sharonmei1219/article/details/7406992)

[声明式编程和命令式编程的比较](http://kb.cnblogs.com/page/181030/)

[命令式和声明式，哪个才是你的菜？](http://www.primeton.com/read.php?id=2318&his=1)

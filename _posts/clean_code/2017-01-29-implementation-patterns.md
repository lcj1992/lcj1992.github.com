---
layout: post
title: 实现模式
categories: clean_code
tags: clean_code
---

* TOC
{:toc}

### 概述

这是一本小书，也是一个好书。

"我惊讶的发现，尽管能够快捷流畅地做出各种编程中的决定，但我没法解释自己为什么如此确定诸如“这个方法为什么应该被这样调用”，或者“那块代码为什么属于那个对象”之类的事情"。这本书在我看来就是解释这些个东西的。

这本书《实现模式》最大的跨度只到类一级，与之相比，设计模式则主要是在讨论类与类之间的关系，"本书的深度应该介于Design patterns和java语言手册之间"。

全书分为7大块，如下图所示

![实现模式](/images/design_pattern/implement-pattern-overview.png)

第一块，总体介绍，几个简短的章节描述了“用代码进行沟通”的重要性和价值所在，以及实现模式背后的思想。自认为是最重要的一块。沟通、简单和灵活这三条价值观为模式提供了广泛的动机。局部化影响、最小化重复、将逻辑和数据捆绑、对称性（匀称性）、声明式表达和变化率这6条原则帮助我们将价值观转化为实际行动，然后开始介绍各种模式。

第二块，类，这部分讲述了为什么要创建类，如何创建类，如何用类来书写逻辑等问题

第三块，状态，关于状态的存取的模式

第四块，行为,这部分模式告诉阅读者如何用代码来编写逻辑，特别是如何用多种不同的方式来做这件事

第五块，方法，关于如何编写方法的模式，他们将告诉你，根据你对方法的分解和命名，阅读者会作出怎样的判断。

第六块和第七块没怎么看，不说了。

这篇文章是这本书的读后感，要求2，3，4，5这几个模块的每个模式尽量都要**落实到工作中所接触到的例子，真真切切感受其好处**。

### 总体介绍

#### 价值观

沟通、简单、灵活

更多的时候，程序是在被阅读而不是被编写。使用模式可以帮助程序员用更合理的方法来解决常见问题，从而把更多时间、精力和创造力留下来解决真正独一无二的问题。

模式描述了要做什么，价值观提供了动机，原则把动机转化成了实际行动。

#### 原则

1. 局部化影响

    组织代码结构时，保证变化只会产生局部化影响，减少变化所引起的代价。

2. 最小化重复

    * DRY，重复代码，
    * 并行的类层次结构。如果修改一处概念，需要修改两个或者更多的类层次结构就标识变化的影响已经扩散了。

3. 将逻辑和数据捆绑
 
    在发生变化是，逻辑和数据很可能会同时被改动，如果把他们放在一起，那么修改他们所造成的影响就会只停留在局部。

4. 对称性

    * 抽象层次要统一
    * 方法名尽量以方法意图来命名

5. 声明式表达

    不太明白作者说的是什么,todo吧。
 
6. 变化率

    * 把具有相同变化率的逻辑和数据放在一起。
    * 变化率同样适用于数据，一个对象中所有成员变量的变化率应该差不多是相同的。
        * 只会在一个方法的生命周期内修改的成员变量应该是局部变量。
        * 两个同时变化，但又和其他成员的变化步调不一致的变量可能应该属于某个辅助对象。
    * 变化率也是对称性的一个应用，不过是时间上的对称。

#### 动机

    Cost(total) = Cost(develop) + Cost(maintain)
    Cost(maintain) = Cost(understand) + Cost(change) + Cost(test) + Cost(deploy)

软件成本可以被分解为初始成本Cost(develop)和维护成本Cost(maintain),而维护成本往往是大头。

在维护时注重程序员之间的沟通，减少理解代码所带来的代价，清晰明确的代码会带来即时收益:代码缺陷更少，更易共享，开发曲线更加平滑。

### 类
   
#### 类

1. 数据的变化比逻辑的变化要频繁的多。

2. 每个类其实就是这样一个声明：这些逻辑应该放在一起，它们的变化不像它们所操作的数据那么频繁，这些数据也应该放在一起，它们变化的频率差不多，并且由与之关联的逻辑来负责处理。

3. 子类传递的信息应该是：我和超类很像，只有少许差异。子类不要覆盖超类的方法。

4. 用类名来讲述代码的故事。

#### 简单的超类名

1. 类名要简短而有表现力，贴切的命名能引发连锁反应，带来更深入的简化和改进。“哦，我明白了，不就是个scheduler么！”

2. 对于重要的类，尽量用一个单词来为它命名

#### 限定性的子类名

1. 子类的名字有两重职责 PayConfirmEventListener EventListener
   
   * 描述它像什么类
   * 还要说明它们之间的区别。
   * 重要性不及继承体系根上的超类或接口,值得牺牲简明来换取更好的表现力，通常在超类名的基础上扩展一两个词

2. 子类也可以拥有一个简单的名字 List Collection

   * 继承只是用作共享实现的机制，并且子类本身就代表了一个重要的概念，那么这样的子类就应该被视为它自己继承体系的根，拥有一个简单的名字

#### 抽象接口
   
1. 应该在确认无疑地需要灵活性时，才应该引入这种灵活性。

2. java有两种方式来表现抽象接口：超类和interface，他们在应对变化时的涉及的成本各有不同。

##### interface

1. 接口的语义：这是我要完成的任务，除此之外的细节不归我操心。更多的反应的是一种能力。

2. 对接口的改变是不被鼓励的。特别是已经有很多的实现方了，改动接口的成本难以估量。

3. 接口的命名
   
   * 如果把interface看做"没有实现的类"，那么就应该像类名一样地给它们命名（简单的超类名，限定性的子类名）
   * 如果具体类的命名对于交流更重要，这种情况下，可以给interface的名字上加上“I”前缀

##### 抽象类

1. java的interface对接口本身的变化支持不佳，一旦改变了interface，所有的实现类都必须同时修改。

2. 抽象类的局限体现在实现类必须对其忠心不二，如果需要以另一视角来看待同一个实现类，就只能让它实现interface了。

3. interface和类继承体系不是互斥的，你可以提供一个接口说“”你可以使用这些功能，再提供一个超类说“这是一种实现方式”。模板方法

##### 有版本的interface  todo 给个例子

1. 和所有设计决策一样，interface还是有可能变化的，如果真遇到需要对interface进行扩展的尴尬局面，可以引入有版本的interface。

#### 值对象 todo 给个项目中的例子

1. 值对象的所有状态都应该在构造器中设置，其他地方不提供改变其内部状态的方式。对于值对象的操作总是返回新的对象，操作的发起者要自己保存返回的对象。

   * 类声明为final的
   * 类中所有属性为final的

2. 会创建临时对象，但考虑整体成本，这种反对意见往往靠不住脚。

3. 组合使用状态可以变的对象和数值一样不可变的对象，能够最好的表现你的程序。

#### 特化

1. 相同的逻辑处理不同的数据, 不同的逻辑处理相同的数据

##### 子类

1. 多用组合，少用继承

2. 缺点 

   * 如果发现父类中一些变化不太适用于子类，就需要先花点功夫把代码从继承关系中解开。
   * 使用者必须先理解超类，然后才能理解子类
   * 对超类的修改颇有风险，因为子类有可能依赖超类中某个微妙的属性
   * 禁止过深的继承体系。
   * 慎重考虑平行的继承体系，是否真的可以平行。
   * 不能表现不断变化的逻辑，所表现的变化在创建对象时就已经清楚了。

##### 实现器

1. 面向接口编程。

#### 内部类*

1. 内部类被实例化时，它的对象会悄悄地获得创建它的那个对象。如果想访问后者的实例数据而有不想在两者之间建立显式的关联，这个特点就显得很方便了。

2. 内部类并没有真正的构造函数，即使声明一个也没用。

3. 将内部类声明为static，将内部类与其所处的对象完全分离


#### 实例特有的行为

一旦各个实例有不同的行为，就需要在运行时观察或者分析数据流才能理解一个对象的行为。为了让代码容易被读懂，即便是实例特有的行为，也最好在对象实例创建之初就确定下来，以后不再改变。？？？？？？todo 举个会改变的例子

##### 条件语句

1. if-else和switch是最简单的方式。

2. 除了修改对象本身的代码之外，没有其他办法来修改它的逻辑。

3. 条件语句的好处在于简单和局部化。

4. 条件语句的增加会降低可靠性。

eg: 简单工厂，通过条件找对应的产品类。不同策略走不同的代码逻辑等等（简单的可以，复杂的最好用策略模式替代之）

##### 委派

1. 要让不同的实例执行不同的逻辑，另一种办法就是把部分工作委派给不同类型的对象；不变的逻辑放在发起委派的类中，变化的逻辑交给委派的对象。

2. 发起委派常用的技巧： 把发起委派的对象作为参数传递给接受委派的方法（不一定哟）

##### 可拔插的选择器

看不太懂 todo

#### 匿名内部类

1. 只在一处使用，api极其简单

eg. Runnable的run方法,Compartor的compare方法

#### 库类

1. 某些功能放在哪些对象中都不合适，可以弄一个空类，在其中创造静态方法，任何人都不应该创建这个类的实例，它只用来安放这些功能

2. 不适合大量使用，把所有逻辑都放在静态方法中就错过了使用对象的最大好处，把数据放入私有命名空间以便简化逻辑，应该尽量把库类变成合格的对象

eg. DateUtils

### 状态

对象包装了行为和状态，前者被暴露给外部世界，后者则为前者提供支持。对象的好处之一便是将程序中所有的状态分割成小块。没一块都有属于自己的计算环境。

#### 状态

1. 函数式编程语言根本不允许改变状态

2. 把系统的状态细分到各个小块中，每个小块的访问都是受到严格限制，从而可以避免状态“在背后偷偷改变”的问题。

3. 有效管理状态的关键在于，把相似的状态放在一起，确保不同的状态彼此分离。对应前边提到的**变化率**的概念

   * 它们在同一个计算中被用到
   * 它们出现和消亡的时间相同

#### 访问

“访问存储值”和“执行计算”，访问内存状态相当于调用一个函数，后者返回当前存储的值，调用函数相当于读取一个内存位置，并对其中的内容进行计算。但不管怎么说，我们的编程语言确实对两者做了区分，因此我们需要清晰的表述它们之间的差异

##### 直接访问

1. 只在访问器方法，构造器中使用直接存储，只在类及其子类，类所在的包的内部使用直接存储。

eg. this.name = name

##### 间接访问

1. 除上条的使用者，其他的使用者必须间接访问。

2. 如果一个对象的某个状态的大部分访问都来自该对象之外，这就说明还有设计问题隐藏在更深的地方。

eg. 其他都是调用getter、setter或者其他具名的方法

#### 通用状态

1. 把具备相同变化率的数据项声明为一个类中的字段。（很多逻辑会涉及同样的数据项，应该把他们共同的数据项声明为一个类中的字段，而不是不加区别的全部罗列）

2. 一个对象中所有的通用状态应该具有同样的作用域和生命周期。 有时我们被诱惑着引入一个这样的字段：它纸杯对象中的一小部分方法使用，或者只有在某个方法被调用的过程中有效，每当遇到这种情况，我总能找到一个更好的地方来保存这部分数据（可能是一个参数或者一个辅助对象），从而改善代码质量

eg.
1. InputWebContextParam中包含InputUserInfo，InputChannelInfo，InputFillOrderInfo， InputPayInfo 将具备不同变化率的数据项分类，

2. 不需要在CreateParam中添加是否异步参数，是否异步生单和真正的生单参数有不同的变化率

#### 可变状态

1. 同一个对象需要不同的额数据元素--不仅是数值改变，就连对象中的数据元素也全然不同，尽管这些对象都来自同一个类。

2. 可变状态通常用map来保存，其中的key是数据元素的名字（变现为字符串或者枚举类型，我更偏爱枚举），值是数据值。

3. 如果遇到一个字段的状态决定了同一个对象中是否需要其他字段，这种情况下就应当使用可变状态。

4. 如果几个变量有相同的前缀，这可能意味着应该引入某种辅助对象。

eg. 窗体是否有框，可以使用通用状态，也可以使用可变状态，也可以使用多态。 todo


#### 外生状态

1. 对于特殊用途的信息，应该保存在使用该信息的地方，而不是保存在对象内部。

todo

#### 变量

1. 代码的阅读者需要知道变量的作用域，生命周期，角色和运行时类型

2. 变量按照其作用域分为三种类型

    * 局部变量，只能在当前作用域中使用
    * 字段，可以在对象内的任何地方访问
    * 静态字段，该类的所有对象都可以访问

3. 可选的修饰符有public，package，protected，private

4. 应该尽量保证变量的生命周期与作用域一致，此外还应该尽量保证兄弟变量（在同一个作用域中定义的变量）有相同的生命周期

5. 用于容纳多个值的变量的名字应该是复数形式的，对于阅读者来说，一个变量包含的一个值还是多个值是非常重要的信息

6. 如果作用域、生命周期和类型都能用别的方式充分描述，名称本身就可以只用于描述变量在计算逻辑中扮演的角色。把需要承载的信息减到最少，就可以选择简洁易读的名称了。

##### 局部变量

1. 遵照“信息最小扩散”原则，应该在尽可能靠内的作用域以及确实需要时才声明局部变量

2. 局部变量常扮演的角色有以下几种：
 
  * 收集器，用变量来收集稍后需要的信息，收集器的内容经常作为返回值传出，如果需要将收集器返回，就将它命名为result或者results
  * 计数， 这是一种特殊的收集器，专门用于记录某些其他对象的个数
  * 解释，如果一个复杂的表达式，可以把表达式的一部分结果赋值给一个局部变量，从而帮助阅读者理解整个复杂的运算
    * 解释型局部变量往往可以再向前走一步，变成辅助方法，表达式变成方法体，局部变量的名字则是给方法命名的线索。
    * 有时引入辅助方法只为了简化主方法，有时它们还而已消除类似的表达式中的重复代码。
  * 复用，如果一个表达式的值会不断变化，而你又需要多次使用同一个值，就应该将这个值保存在局部变量中。eg 。Date now = new Date();
  * 元素，局部变量最后哦一个常见的用途就是在迭代遍历集合时指代其中的元素

##### 字段

1. 我更愿意在阅读代码时首先看到数据的声明，我也是

2. 可以选择把字段声明为final，以此告诉阅读者，构造函数执行完之后就不能再改变该字段的值了. eg OrderCreationContext 中的orderDisplayId字段

3. 字段承担的几种常见角色

  * 助手，助手字段用于存放其他对象的引用，该对象会被当前对象的很多方法用到，如果有一个对象以参数的方式传递给很多个方法，就可以考虑改为通用助手字段(而不是参数)获得所需的对象，并在构造函数中给助手字段赋值。 todo
  * 标记，boolean型的标记表示“这个对象可能有两种不同的行为方式”。如果这个标记再有setter方法，那就表示“而且行为可能在对象生命周期中发生改变”
  * 策略，如果想表达“这部分计算有几种不同的额方式来进行”，就应该把一个“只执行这部分可变的计算”的对象保存在一个字段中。如果计算方式在对象生命周期中不发生变化，就在构造函数中给策略字段赋值，否则就提供一个方法来改变策略字段的值
  * 状态，状态字段和策略字段有相似之处，它们所在的对象都会把一部分行为委派给它们，但状态字段在被触发时会自己设置相关的状态，而策略字段即便会发生改变，这改变也是由其他对象来进行的。用状态字段实现的状态机会很难理解，因为状态和变迁不在同一个地方描述
  * 组件，这样的字段用来保存由所在对象“拥有”的对象或者数据。

##### 参数

1. 由于非私有变量会在类与类之间造成强耦合，而且这种耦合会与日剧增，所以只要可能，就应该尽可能使用参数来传递状态

2. 参数是将对象联系起来的细线，但是足够多的细线也能把一个对象束缚起来动弹不得，所以如果一个对象给另一个对象的很多消息都需要同一个参数，那么也许更好的办法是把这个参数永久地交给被调的对象

##### 收集参数

todo

##### 可选参数

1. 套筒型参数列表

##### 变长参数

1. 变长参数必须位于参数列表的最后，如果一个方法既有变长参数，又有前面介绍的可选参数，那么可选参数也必须放在变长参数的前面

##### 参数对象

1. 如果同一组参数被放在一起传递给了很多个方法，就应该考虑创建一个对象，把这些参数放入该对象的字段，然后传递这个对象。

2. 参数对象的引入让代码变得更短，意图更清晰。

3. 尽管引入参数对象的主要目的是提高可读性，但参数对象也可以成为逻辑的重要去处，同一组数据在几个参数列表中出现，这本身就明白无疑的说明“这一组数据是强关联的”

#### 常量

1. 禁止出现魔法值，可以避免整整一大类的错误，是封装变化的很好体现。

#### 按角色命名

1. 变量名应该体现变量中的数据会被如何使用，以及这些数据在计算逻辑中扮演什么角色， 其他关于这个变量的重要信息-生命周期、作用域和类型，通常从上下文中就可以找到。

#### 声明时的类型

1. 如果可能，把变量和方法的类型声明的宽泛一些会有好处，但降低一点宽泛程度、损失一点精确性来获取一致性，也是合理的权衡。

#### 初始化

1. 我们希望尽量在声明的同时初始化，如果初始化和声明放在一起，那么与这个变量相关的问题都能从这个地方找到答案

2. 另一方面，性能总是需要考虑的，那些初始化成本很高的变量很可能需要在声明之后的某个时候才初始化。

##### 及早初始化

1. 可以保证变量在使用之前一定是被初始化过的

##### 延迟初始化

1. 延迟初始化给阅读者传递的信息是： 此处性能很要紧

### 参考

[实现模式中的“对称性”](http://blog.csdn.net/sharonmei1219/article/details/7406992)

[声明式编程和命令式编程的比较](http://kb.cnblogs.com/page/181030/)

[命令式和声明式，哪个才是你的菜？](http://www.primeton.com/read.php?id=2318&his=1)

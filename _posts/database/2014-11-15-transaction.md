---
layout: post
title: 事务隔离级
categories: db
description: 事务隔离级
keywords: database
---
   
### 事务隔离级  
数据库中的基本锁机制：排它锁（写锁，X锁）和共享锁（读锁，S锁）    
*排它锁*（写锁，X锁）事务T对数据对象A加了X锁，其他事务就不能对A加锁了，直到T释放A上的锁，这样就保证了其他事务在T释放A上的锁之前不能读或者写A    
*共享锁*（读锁，S锁）事务T对数据对象A加了S锁，可以对读A但是不能写A，其他事务可以对A加S锁，读A，但是不能加X锁，写A，直到事务T释放A上的锁。  
  
事务的ACID特性：    
  A 原子性　atomic 要么做要么不做。是一体的，原子是什么，不可分割的啊。（不过好像有夸克了，原子也是可以分的，哈哈哈）
  C 一致性  consistency 只能从一个状态到另一个状态，数据库中只包含成功commit的结果，没有夭折的事务残留。
  I 隔离性  isolation 事务的执行不受其他并发事务的的影响。
  D 持久性  durability 事务一旦提交，他对数据库的影响必须是永久的。
  
  
事务隔离级       隔离级的设置只对当前事务有效  
Read Uncommited 读未提交， 如果事务T1的隔离级是Read Uncommited，则T1可能读到未提交的数据（脏数据）  
Read Commited 读提交， 如果事务T1的隔离级是Read Commited，则T1只能读到已提交数据，但是每次读到的数据不一定相同   。  
Repeatable Read可重复读，一个事务内，所有的查询操作（select）的结果都是一样的。但是可能出现幻读。  
Serializable 串行化，事务A结束后，事务B才能进行。不会出现脏数据，不会出现不可重复读现象，不会出现幻读。  **唯一满足事务ACID特性的隔离级别。**

***读提交与可重复读级别***    

`读提交`的读写操作都是对于数据库本身，而`可重复读` *读*针对的是数据库的镜像，而*写*针对的是数据库本身。  
所有的*写*操作都是在内存中，只有当commit时才写回磁盘。

engine为innodb时，隔离级：可重复读，innodb是行锁。
事务A更新id= 1的行，取得该行的x锁，
然后事务B更新id = 2的行，取得该行的x锁，
然后事务A也想更新id= 1的行就得等事务B释放该行x锁，
事务B又想更新id = 2的行，等事务A释放该行x锁，这样就造成了死锁。
innodb 可以识别出死锁的情形，会把后起的那个事务回滚，先起的事务执行但是并未提交。
（**结束事务的两种不同的方式：回滚或者提交**）



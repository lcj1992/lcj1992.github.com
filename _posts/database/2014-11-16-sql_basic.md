---
layout: post
title: sql基础
categories: db
tags: sql
---

*   [select 执行顺序](#select)
    *   [细解](#sql)
*   [索引](#index)
*   [存储过程]
*   [函数]
*   [参考](#ref)

## select sql执行顺序 {#select}

        (8)SELECT (9)DISTINCT
        (11)<TOP_specification> <select_list>
        (1)FROM <left_table>
        (3)　<join_type> JOIN <right_table>
        (2)　 ON <join_condition>
        (4)WHERE <where_condition>
        (5)GROUP BY <group_by_list>
        (6)WITH {CUBE | ROLLUP}
        (7)HAVING <having_condition>
        (10)ORDER BY <order_by_list>

     
执行顺序:

`笛卡尔积---on---join类型---where---group by---with{cube | rollup}---having---select---distinct---order by---top`

### 细解 {#sql}

1.  on与where的区别
    两者效果可能一样，但on是连接两表做笛卡尔积时的连接条件，where连接之后的筛选条件。

2.  where 和 having的区别

    1.  where 子句的作用是在对查询结果进行分组前(`group by 之前`)，将不符合where条件的行去掉，即在分组之前过滤数据， ***where条件中不能包含聚集函数***，使用where条件过滤出特定的行。
    
    2.  having 子句的作用是筛选满足条件的组(`group by 之后`,having是专门搭配group by干活的)，即在分组之后过滤数据，条件中经常包含聚组函数，使用having条件过滤出特定的组，也可以使用多个分组标准进行分组。

3.  join、left join、right join　　
    eg table_a,table_b

    1.  left join 以左为准，右可以为空, 记录数>=table_a总数
    2.  right join 以右为准，左可以为空，记录数>=table_b总数

4.  group by

    1.  先对某一列或多列进行分组，然后在分组内进行相应的操作，一般和count，max等聚集函数一起使用。
    
    2.  聚集函数与列不能同时出现在select子句中，除非这个列是group by子句的分组列,参见下错误例子
    
    3.  当查询语句中有group by子句时，聚集函数作用的对象是一个分组，而不是整个查询的结果,没有group by的话是整个查询结果
    
        select DepartmentId,Name,count(Salary) from Employee group by Name;
        Error Code: 1055. Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'test.Employee.DepartmentId' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by
            

5.  order by

对某一列进行排序,发生在select，distinct之后

6.  limit

取出结果的几个 eg：limit 1,2从1开始的2个。  查询结果是从0 开始的

7.  union和union all

跨库查询，union会去重，union all 不会去重

8.  ps

    1.  update product_details set weight=38, exist = 1 where name = 'jim'// 更新操作,and是错误的　

    2.  create table select ：创建一个和原表字段结构一致的新表，去掉所有的约束，同时将原表select的结果数据插入新表　　　　

    3.  create table like ： 创建一个和原表结构完全一致的新空表，包含全部约束　　　　

    4.  on 后连接的字段要考虑设计索引。　　

    5.  show variables like 'log_slow_queries';　查看是否启用慢日志　

    6.  show  variables like 'long_query_time';　查看慢于多少秒的sql会记录到慢日志中

    7.  涉及数据库的字段更改,需要考虑读取,写入的时间段,考虑 ***兼容性***,  ***老数据***,`发布过程服务不能停`,注意***版本***的概念.    

## 索引 {#index}

1.  查看表的索引　　

        show index from tb_xx;
2.  添加表的索引,唯一索引，主键　　

        alter table tb_xx add index `idx_site_channel_status`(`site`,`channel`,`status`)
        alter table tb_xx unique `uniq_name`(`name`)
        alter table tb_xx primary key  `id` (`id`)
3.  删除表的索引　　

        alter table tb_xx drop index `idx_site_channel_status`　　　/　　drop index `idx_site_channel_status` on tb_xx;
        alter table tb_xx drop index `uniq_name` (*跟删除普通的索引是一样的*)
        alter table tb_xx drop primary key;
    ps: **auto_increment只能作用于key,删除有auto_increment约束的索引时，必须先将auto_increment约束删除**

## 参考 {#ref}

[1]<http://www.dofactory.com/sql/alias>

[2]<http://www.cnblogs.com/JohnABC/p/3309144.html>

[mysql查询技巧]<http://mp.weixin.qq.com/s?timestamp=1462151732&src=3&ver=1&signature=OSVBirQ*w6WZWLcZjH6vpvdgkDEJmVj*2H8YvyHQ*kU3SMtwHC8UZjxCuA7yZG-okuygUsbvjIWjyYv0kzUA6EY59CrHnmPfjAS6z6wa9mVuYVuLetcoDSLcqObopAFRKJTeX*wR6B4E9m0GRcdt-TAvRLRKqxJMgkjiEN6WVls=>



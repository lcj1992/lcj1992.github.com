---
layout: post
title: 如何设计查询语句
categories: db
tags: sql
---

*   [select 执行顺序](#select)
    *   [细解](#sql)
*   [参考](#ref)

## select sql执行顺序 {#select}

        (8)SELECT (9)DISTINCT
        (11)<TOP_specification> <select_list>
        (1)FROM <left_table>
        (3)　<join_type> JOIN <right_table>
        (2)　 ON <join_condition>
        (4)WHERE <where_condition>
        (5)GROUP BY <group_by_list>
        (6)WITH {CUBE | ROLLUP}
        (7)HAVING <having_condition>
        (10)ORDER BY <order_by_list>
笛卡尔积---on---join类型---where---group by---with{cube | rollup}---having---select---distinct---order by---top

### 细解 {#sql}
1.  on与where的区别
两者效果可能一样，但on是连接两表做笛卡尔积之前的连接条件，where连接之后的筛选条件。

2.  where 和 having的区别
where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，*where条件中不能包含聚集函数*，使用where条件过滤出特定的行。
having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having条件过滤出特定的组，也可以使用多个分组标准进行分组。

3.  join、left join、right join　　
eg table_a,table_b
left join 以左为准，右可以为空, 记录数为table_a 总数
right join 以右为准，左可以为空，记录数为table_b总数

4.  group by
先对某一列或多列进行分组，然后在分组内进行相应的操作，一般和count，max等聚集函数一起使用，聚集函数作用的是一个分组，而不是整个查询结果。
聚集函数与列不能同时出现在select子句中，除非这个列是group by子句的分组列
当查询语句中有group by子句时，聚集函数作用的对象是一个分组，而不是整个查询的结果,没有group by的话是整个查询结果

5.  order by
对某一列进行排序,发生在select，distinct之后

6.  limit
取出结果的几个 eg：limit 1,2从1开始的2个。  查询结果是从0 开始的

7.  union和union all
跨库查询，union会去重，union all 不会去重

8.  ps

    1.  update product_details set weight=38, exist = 1 where name = 'jim'// 更新操作,and是错误的　

    2.  create table select ：创建一个和原表字段结构一致的新表，去掉所有的约束，同时将原表select的结果数据插入新表　　　　

    3.  create table like ： 创建一个和原表结构完全一致的新空表，包含全部约束　　　　

    4.  on 后连接的字段都要设计索引。　　

    5.  show variables like 'log_slow_queries';　查看是否启用慢日志　

    6.  show  variables like 'long_query_time';　查看慢于多少秒的sql会记录到慢日志中

    7.  涉及数据库的字段更改,需要考虑读取,写入的时间段,考虑 ***兼容性***,  ***老数据***,`发布过程服务不能停`,注意***版本***的概念.    


### 参考 {#ref}
[1]<http://www.dofactory.com/sql/alias>

[2]<http://www.cnblogs.com/JohnABC/p/3309144.html>



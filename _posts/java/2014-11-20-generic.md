---
layout: post
title: 泛型
categories: java
tags: 类型擦除 类型推导 运行时 编译时
---


### 概述

想象一下,如果没有泛型,如何使用集合中的某一个对象,必须get之后强转吧,如果有人不小心插入了类型错误的对象,在`运行时`的转换就会出错.
`泛型`可以告诉编译器代码块(类,方法)接受哪些类型的对象,在`编译时`通过`类型推导`,告知是否插入了错误类型的对象,
泛型可以保证在同一代码块内,类型一致.

声明中具有一个或者多个类型参数的类或者接口,就是泛型类或者接口,简称`泛型`.eg List<E>就读作E的列表.
每个泛型都定义`一组参数化的类型`,定义`一个原生态类型`.声明在`类名之后`或者`方法返回值之前`

1.几个术语:

|术语|示例|
|-|-|
|参数化的类型  | `List<String>`
|  实际类型参数|`String`|
|  泛型|`List<E>`|
|  形式类型参数|`E`|
|  无限制通配符类型|`List<?>`|
|  原生态类型|`List`|
|  有限制类型参数|`<E extends Number>`|
|递归类型限制|`<T extends Comparable<T>>`|
|  有限制通配符类型|`List<? extends Number>`|
| 泛型方法|`static <E> List<E> asList(E[] a)`|
| 类型令牌|`String.class`|

2.例子:
    class AClass<T,K,V>{}   
    <T>String aMethod(T t){}    
    <T extends Aclass>String aMethod(T t){} 
    List<? extends AClass> aMethod(){}
 
### List,List<?>和List<E>的区别

|类型|编译检查|元素|
|-|-|-|
|原生态类型(List)|编译时不做检查|List元素可能不一致,这就是坑的所在|
|无限制通配类型(List<?>)|编译时做检查|List的元素必须是一致的,不能增加除null外的元素|
|泛型(List<E>)|在编译时做类型推导,然后做检查|List的元素必须是一致的,且可以在后边引用使用|

### 参考

[泛型的内部原理：类型擦除以及类型擦除带来的问题]<http://blog.csdn.net/lonelyroamer/article/details/7868820>

[类型推导]<http://blog.csdn.net/zerro99/article/details/6118218>

[无限制的通配符]<http://bbs.csdn.net/topics/390349747>

---
layout: post
title: 泛型
categories: java
tags: 类型擦除 类型推导 运行时 编译时
---


想象一下,如果没有泛型,如何使用集合中的某一个对象,必须get之后强转吧,如果有人不小心插入了类型错误的对象,在`运行时`的转换就会出错.
`泛型`可以告诉编译器代码块(类,方法)接受哪些类型的对象,在`编译时`通过`类型推导`,告知是否插入了错误类型的对象,
泛型可以保证在同一代码块内,类型一致.

声明中具有一个或者多个类型参数的类或者接口,就是泛型类或者接口,简称`泛型`.eg List<E>就读作E的列表.
每个泛型都定义`一组参数化的类型`,定义`一个原生态类型`.声明在`类名之后`或者`方法返回值之前`


几个术语:

|术语|示例|
|-|-|
|参数化的类型  | `List<String>`
|  实际类型参数|`String`|
|  泛型|`List<E>`|
|  形式类型参数|`E`|
|  无限制通配符类型|`List<?>`|
|  原生态类型|`List`|
|  有限制类型参数|`<E extends Number>`|
|递归类型限制|`<T extends Comparable<T>>`|
|  有限制通配符类型|`List<? extends Number>`|
| 泛型方法|`static <E> List<E> asList(E[] a)`|
| 类型令牌|`String.class`|


    class AClass<T,K,V>{}   
    <T>String aMethod(T t){}    
    <T extends Aclass>String aMethod(T t){} 
    List<? extends AClass> aMethod(){}
 



上界用extends关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。     
下界用super进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至Object    

### 参考

[泛型的内部原理：类型擦除以及类型擦除带来的问题]<http://blog.csdn.net/lonelyroamer/article/details/7868820>

[类型推导]<http://blog.csdn.net/zerro99/article/details/6118218>

[无限制的通配符]<http://bbs.csdn.net/topics/390349747>

---
layout: post
title: HashMap源码注解
categories: java
---

*   [类图](#class_graph)
*   [Map](#Map)
*   [AbstractMap](#AbstractMap)
*   [HashMap](#HashMap)


### 类图 {#class_graph}

![map类图](/images/java/map.png)

### Map {#Map}

Map内部子接口Entry (条目), 用户存储一条一条的键值对

*   size() 返回map的entry数
*   isEmpty() size()为0 
*   containsKey(Object key) 是否包含key
*   containsValue(Object value) 是否包含value
*   get(Object key) 返回key对应的value
*   put(K key, V value) 添加键值对
*   remove(Object key) 删除key对应键值对,返回value
*   putAll(Map\<? extends K,? extends V\> m) 拷贝m到这个map中
*   clear() 清空所有键值对
*   keySet() 返回所有的key的 Set\<K\>
*   values() 返回所有的values Collection\<V\>
*   entrySet() 返回所有entry的 Set\<Map.Entry\<K,V\>\>
*   Entry<K,V> 
    *   getKey() 返回该entry的key
    *   getValue()  返回该entry的value
    *   setKey()
    *   setValue()
    *   equals(Object o) 重写equals方法
    *   hashCode() 重写了equals方法就要重写hashCode()方法
*   equals(Object o) 重写equals方法
*   hashCode() 重写了equals方法就要重写hashCode()方法

### AbstractMap

对Map接口的方法进行实现,不对Entry接口进行实现,SimpleEntry(可变的) 和 SimpleImmutableEntry(不可变的),都是只有key value 两个属性 

### HashMap
HashMap有两个比较重要的域 

*   threshold 阈值,代表hashmap存放内容数量的一个临界点，当存放量大于这个值的时候(capacity > threshold)，就需要将table进行扩张，也就是新建一个两倍大的数组，并将老的元素转移过去。threshold = (int)(capacity * loadFactor);
*   loadFactor 负载因子，是实际存放量/capacity容量 的一个比值，在代码中这个属性是描述了装载因子的最大值，默认大小为0.75

HashMap有九个内部类

*   Holder 存储alternative的容量下限
*   Entry hashMap的Entry长这样

        final K key;
        V value;
        Entry<K,V> next;
        int hash;
*   EntrySet entry的Set
*   KeySet key的Set
*   Values values的collection
*   HashIterator 抽象的hash表的Iterator
*   EntryIterator 继承HashIterator Entry的Iterator
*   KeyIterator 继承HashIterator Key的Iterator
*   ValueIterator 继承HashIterator Value的Iterator

### hashMap的死循环问题

```
/**
* Transfers all entries from current table to newTable.
*/
void transfer(Entry[] newTable, boolean rehash) {
   int newCapacity = newTable.length;
   for (Entry<K,V> e : table) {
       while(null != e) {
           Entry<K,V> next = e.next;
           if (rehash) {
               e.hash = null == e.key ? 0 : hash(e.key);
           }
           int i = indexFor(e.hash, newCapacity);
           e.next = newTable[i];
           newTable[i] = e;
           e = next;
       }
   }
}
```
        
### 参考

[1]<http://coolshell.cn/articles/9606.html>
[2]<http://blog.csdn.net/xuefeng0707/article/details/40797085>
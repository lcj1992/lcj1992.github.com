---
layout: post
title: HashMap
categories: java
---

*   [类图](#class_graph)
*   [Map](#map)
*   [AbstractMap](#abstractMap)
*   [HashMap](#hashMap)
*   [HashMap并发下的死循环](#infiniteLoop)


### 类图 {#class_graph}

![map类图](/images/java/map.png)

### Map 

Map内部子接口Entry (条目), 用户存储一条一条的键值对

*   size() 返回map的entry数
*   isEmpty() size()为0 
*   containsKey(Object key) 是否包含key
*   containsValue(Object value) 是否包含value
*   get(Object key) 返回key对应的value
*   put(K key, V value) 添加键值对
*   remove(Object key) 删除key对应键值对,返回value
*   putAll(Map\<? extends K,? extends V\> m) 拷贝m到这个map中
*   clear() 清空所有键值对
*   keySet() 返回所有的key的 Set\<K\>
*   values() 返回所有的values Collection\<V\>
*   entrySet() 返回所有entry的 Set\<Map.Entry\<K,V\>\>
*   Entry<K,V> 
    *   getKey() 返回该entry的key
    *   getValue()  返回该entry的value
    *   setKey()
    *   setValue()
    *   equals(Object o) 重写equals方法
    *   hashCode() 重写了equals方法就要重写hashCode()方法
*   equals(Object o) 重写equals方法
*   hashCode() 重写了equals方法就要重写hashCode()方法

### AbstractMap

对Map接口的方法进行实现,不对Entry接口进行实现,SimpleEntry(可变的) 和 SimpleImmutableEntry(不可变的),都是只有key value 两个属性 

### HashMap
HashMap有两个比较重要的域 

*   threshold 阈值,代表hashmap存放内容数量的一个临界点，当存放量大于这个值的时候(capacity > threshold)，就需要将table进行扩张，也就是新建一个两倍大的数组，并将老的元素转移过去。threshold = (int)(capacity * loadFactor);
*   loadFactor 负载因子，是实际存放量/capacity容量 的一个比值，在代码中这个属性是描述了装载因子的最大值，默认大小为0.75

HashMap有九个内部类

*   Holder 存储alternative的容量下限
*   Entry hashMap的Entry长这样

        final K key;
        V value;
        Entry<K,V> next;
        int hash;
*   EntrySet entry的Set
*   KeySet key的Set
*   Values values的collection
*   HashIterator 抽象的hash表的Iterator
*   EntryIterator 继承HashIterator Entry的Iterator
*   KeyIterator 继承HashIterator Key的Iterator
*   ValueIterator 继承HashIterator Value的Iterator

### hashMap的死循环问题 {#infiniteLoop}

hash死循环发生在两个或多个线程同时对hashMap resize过程中 transfer会造成entry和它的next反转,死循环

    void transfer(Entry[] newTable)
    {
        Entry[] src = table;
        int newCapacity = newTable.length;
        //  从OldTable里摘一个元素出来，然后放到NewTable中
        for (int j = 0; j < src.length; j++) {
            Entry<K,V> e = src[j];
            if (e != null) {
                src[j] = null;
                do {
                    Entry<K,V> next = e.next;
                    int i = indexFor(e.hash, newCapacity);
                    e.next = newTable[i];
                    newTable[i] = e;
                    e = next;
                } while (e != null);
            }
        }
    }

idea debug 默认是所有工程级别,可以改成线程级别进行多线程的debug

`run - View Breakpoints - Suspend 改为default 然后make default`,以后你的idea就都是线程级别的了,切换不同线程进行多线程的debug
    
### 参考

[1]<http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html>

[2]<http://coolshell.cn/articles/9606.html>
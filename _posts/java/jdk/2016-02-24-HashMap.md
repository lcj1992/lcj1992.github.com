---
layout: post
title: HashMap
categories: java
---

*   [类图](#class_graph)
*   [Map](#map)
*   [AbstractMap](#abstractMap)
*   [HashMap](#hashMap)
*   [HashMap X问](#qAnda)
    *   [为什么并发下会死循环?](#infiniteLoop)
    *   [为什么table的length都是2的幂,这样做有什么好处?](#table_size)
    *   [hashCode如何提高HashMap的性能](#hashcode)
    
### 类图 {#class_graph}

![map类图](/images/java/map.png)

### Map 

Map内部子接口Entry (条目)

*   size() 返回map的entry数
*   isEmpty() size()为0 
*   containsKey(Object key) 是否包含key
*   containsValue(Object value) 是否包含value
*   get(Object key) 返回key对应的value
*   put(K key, V value) 添加键值对
*   remove(Object key) 删除key对应键值对,返回value
*   putAll(Map\<? extends K,? extends V\> m) 拷贝m到这个map中
*   clear() 清空所有键值对
*   keySet() 返回所有的key的 Set\<K\>
*   values() 返回所有的values Collection\<V\>
*   entrySet() 返回所有entry的 Set\<Map.Entry\<K,V\>\>
*   Entry<K,V> 
    *   getKey() 返回该entry的key
    *   getValue()  返回该entry的value
    *   setKey()
    *   setValue()
    *   equals(Object o) 重写equals方法
    *   hashCode() 重写了equals方法就要重写hashCode()方法
*   equals(Object o) 重写equals方法
*   hashCode() 重写了equals方法就要重写hashCode()方法,为什么?请看[一道题目来说equals和hashCode](/2016/03/12/equals_hashCode_example)

### AbstractMap

对Map接口的方法进行实现,不对Entry接口进行实现,SimpleEntry(可变的) 和 SimpleImmutableEntry(不可变的),都是只有key value 两个属性 

### HashMap

HashMap 数据结构为`数组`(table\[Engty\])+ `链表`(Entry.next),其Entry四个域,key,value,`next`,`hash`

HashMap两个比较重要的域 

*   threshold 阈值,代表hashMap存放内容数量的一个临界点，当存放量大于这个值的时候(capacity > threshold)，就需要将table进行扩张，也就是新建一个两倍大的数组，并将老的元素转移过去。threshold = (int)(capacity * loadFactor);
*   loadFactor 负载因子，是实际存放量/capacity容量 的一个比值，在代码中这个属性是描述了装载因子的最大值，默认大小为0.75

HashMap九个内部类

*   Holder 存储alternative的容量下限
*   Entry hashMap的Entry长这样,

        final K key;
        V value;
        Entry<K,V> next;
        int hash; // HashMap#hash(Object key)的值
*   EntrySet entry的Set
*   KeySet key的Set
*   Values values的collection
*   HashIterator 抽象的hash表的Iterator
*   EntryIterator 继承HashIterator Entry的Iterator
*   KeyIterator 继承HashIterator Key的Iterator
*   ValueIterator 继承HashIterator Value的Iterator

### HashMap X问 {#qAnda}

#### 为什么并发下会死循环 {#infiniteLoop}

hash死循环发生在两个或多个线程同时对hashMap resize过程中 transfer会造成entry和它的next反转,造成死循环,具体详见[耗子叔叔的](http://coolshell.cn/articles/9606.html),写的已经很好了.

    void transfer(Entry[] newTable)
    {
        Entry[] src = table;
        int newCapacity = newTable.length;
        //  从OldTable里摘一个元素出来，然后放到NewTable中
        for (int j = 0; j < src.length; j++) {
            Entry<K,V> e = src[j];
            if (e != null) {
                src[j] = null;
                do {
                    Entry<K,V> next = e.next;
                    int i = indexFor(e.hash, newCapacity);
                    e.next = newTable[i];
                    newTable[i] = e;
                    e = next;
                } while (e != null);
            }
        }
    }

告诉你个调试的小秘密

idea debug 默认是所有工程级别,可以改成线程级别进行多线程的debug

`run - View Breakpoints - Suspend 改为default 然后make default`,以后你的idea就都是线程级别的了,切换不同线程进行多线程的debug
  
#### 为什么其内部table的length都是2的幂 {#table_size}

什么,不一定是2的幂? 

***一定的***. 详情见HashMap#inflateTable  -> HashMap#roundUpToPowerOf2 ->  [Integer.highestOneBit](/2016/03/07/Integer) 

扩容也是乘以2,所以是一定的.那么为什么要这么做呢?

可以保证entry分配均匀,[详见](/2016/03/12/equals_hashcode_example/indexFor)

### hashCode如何提高HashMap的性能 {#hashcode}

具体在在equals hashcode中有讲[详见]</2016/03/10/equals_hashcode/hashCode_hash_based>

### 参考

[1]<http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html>

[2]<http://coolshell.cn/articles/9606.html>

[3]<http://nanguocoffee.iteye.com/blog/907824>
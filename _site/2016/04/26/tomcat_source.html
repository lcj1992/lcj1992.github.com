<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="baidu-site-verification" content="vuaTJrjFLn" />
    <meta name="keywords" content="foolchild,linux,java,技术,互联网" />
    <meta name="description" content="技术博客，记录foolchild技术道路上成长的点滴" />
    <title> tomcat的启动关闭与请求处理  </title>
    <link rel="stylesheet" href="/css/default.css" type="text/css"/>
    <link rel="stylesheet" href="/css/small.css" type="text/css" media="(max-width: 720px)"/>
    <link rel="stylesheet" href="/css/syntax.css" type="text/css"/>
    <link rel="stylesheet" href="/css/bootstrap.css" type="text/css"/>
    <link rel="stylesheet" href="/css/codeboy.css" type="text/css"/>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
</head>
<body>
<div id="container">
    <div class="nav">
    <div class="nav_nav">
        <a href="/">首页</a>
        <a href="/categories.html">分类</a>
        <a href="/booklist.html">书单</a>
        <a href="/about.html">关于</a>
    </div>
</div>

    <div id="main">
        <h2> tomcat的启动关闭与请求处理 </h2>
        <p>基于7.0.42.0, tomcat源码导入idea<a href="/2015/12/28/import_tomcat_to_idea">参看这篇</a></p>

<h4 id="background">背景</h4>

<p>最早看tomcat源码是为了研究spring mvc的启动,然后有了个了解也就放那了.这次看是源于<a href="2016/04/29/airline_av">airlineav的调优</a></p>

<p>毕竟工作中遇到技术性的问题也不多,再放任其走掉,什么时候能提高,尽自己能力尽可能地深入总能有所收获. 尝试着改了下tomcat的参数,发现好像有必要研究下它的源码,毕竟这是工作中接触最广的开源项目之一了.</p>

<h4 id="structure">整体架构</h4>

<p><img src="/images/soft/tomcat_structure.jpg" alt="tomcat架构" /></p>

<ol>
  <li><code class="highlighter-rouge">Server</code>(服务器)顶级构成元素,所有一切包含在Server中,Server的实现类StandardServer可以包含一个到多个service</li>
  <li><code class="highlighter-rouge">Service</code>(服务)次顶级元素,其实现类为StandardService调用Container(容器)的接口,实际是调用Engine,而且StandardService类中也指明了该Service归属的Server</li>
  <li><code class="highlighter-rouge">Container</code> (容器) Host(主机),Context(上下文),Engine(引擎)均继承自Container接口.但是他们是有父子关系的,在Host(主机),Context(上下文)和Engine(引擎)这三类容器中,Engine是顶级容器,直接包含Host,而Host又包含Context,所以Engine,Host和Context从大小上来说又构成父子关系.</li>
  <li><code class="highlighter-rouge">Connector</code> (连接器) 将Service和Container链接起来,首先它需要注册到一个Service,它的作用就是把来自客户端的请求转达到Container,这就是它为什么称作连接器的原因.</li>
</ol>

<p>所以从功能的角度将tomcat分为5个子模块,他们分别是:</p>

<ol>
  <li>Jasper模块: 负责jsp页面的解析,jsp属性的验证,同时也负责将jsp页面动态转换为java代码并编译成class文件,tomcat源码中org.apache.jasper包及其自爆的源码都属于这个子模块</li>
  <li>Servlet和Jsp规范的实现模块: 源码位于javax.servlet包及其子包,javax.servlet.Servlet接口,javax.servlet.http.httpServlet类等就位于这个子模块</li>
  <li>Catalina子模块: 包含org.apache.catalina开头的源码.该子模块的任务是规范Tomcat的总体架构,定义了Server,Service,Host,Connector,Context,Session及Cluster等关键组件及这些组件的实现,这个子模块大量运用了Composite设计模式.同时也规范了Catalina的启动关闭等事件的执行流程.</li>
  <li>Connectors子模块:  如果说上面三个子模块实现了tomcat应用服务器的话,那么这个子模块就是web服务器的实现.所谓连接器就是一个连接客户和应用服务器的桥梁,他接收用户的请求,并把用户请求包装成标准的Http请求(包含协议名称,请求头Head,请求方Get或者Post等)
同时在请求页面未发现时,connector就会给客户端浏览器发送标准的Http 404错误相应页面</li>
  <li>Resource子模块: 这个子模块包含一些资源文件,如Server.xml及Web.xml配置文件.严格来说,这个子模块不包含java源代码,但是它是tomcat编译运行所必需的.</li>
</ol>

<h4 id="start_stop">启动关闭流程</h4>

<p>这个日志熟悉么? 不熟悉的话,重启下你机器上的任一tomcat项目,熟悉一下</p>

<div class="highlighter-rouge"><pre class="highlight"><code>May 07, 2016 2:13:51 PM org.apache.catalina.core.StandardServer await
INFO: A valid shutdown command was received via the shutdown port. Stopping the Server instance.
May 07, 2016 2:13:51 PM org.apache.coyote.AbstractProtocol pause
INFO: Pausing ProtocolHandler ["http-bio-8080"]
May 07, 2016 2:13:51 PM org.apache.catalina.core.StandardService stopInternal
INFO: Stopping service Catalina
May 07, 2016 2:13:52 PM org.apache.catalina.loader.WebappClassLoader clearReferencesThreads
SEVERE: The web application [] appears to have started a thread named [AsyncAppender-Worker-Thread-3] but has failed to stop it. This is very likely to create a memory leak.
ay 07, 2016 2:13:53 PM org.apache.coyote.AbstractProtocol stop
INFO: Stopping ProtocolHandler ["http-bio-8080"]
May 07, 2016 2:13:53 PM org.apache.coyote.AbstractProtocol destroy
INFO: Destroying ProtocolHandler ["http-bio-8080"]
May 07, 2016 2:13:55 PM org.apache.catalina.loader.WebappClassLoader loadClass
INFO: Illegal access: this web application instance has been stopped already.  Could not load org.I0Itec.zkclient.ZkClient$8.  The eventual following stack trace is caused by an error thrown for debugging purposes as well as to attempt to
...

May 06, 2016 10:59:56 PM org.apache.coyote.AbstractProtocol init
INFO: Initializing ProtocolHandler ["http-bio-8080"]
May 06, 2016 10:59:56 PM org.apache.catalina.startup.Catalina load
INFO: Initialization processed in 1157 ms
May 06, 2016 10:59:56 PM org.apache.catalina.core.StandardService startInternal
INFO: Starting service Catalina
May 06, 2016 10:59:56 PM org.apache.catalina.core.StandardEngine startInternal
INFO: Starting Servlet Engine: Apache Tomcat/7.0.47
May 06, 2016 10:59:56 PM org.apache.catalina.startup.HostConfig deployDirectory
INFO: Deploying web application directory /xxx.com/webapps/ROOT
May 06, 2016 10:59:58 PM org.apache.coyote.AbstractProtocol start
INFO: Starting ProtocolHandler ["http-bio-8080"]
May 06, 2016 10:59:58 PM org.apache.catalina.startup.Catalina start
INFO: Server startup in 1818 ms
</code></pre>
</div>

<p>tomcat的入口为<code class="highlighter-rouge">BootStrap#main</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>Bootstrap loader for Catalina.  This application constructs a class loader
for use in loading the Catalina internal classes (by accumulating all of the
JAR files found in the "server" directory under "catalina.home"), and
starts the regular execution of the container.  The purpose of this
roundabout approach is to keep the Catalina internal classes (and any
other classes they depend on, such as an XML parser) out of the system
class path and therefore not visible to application level classes.
</code></pre>
</div>

<p>大致意思:Catalina的启动加载器,加载catalina.home目录下的classes,并启动容器.</p>

<p>这样保证了Catalina内部的类不在系统的path下,因此对于其他应用是不可见的(应用隔离)(自定义类加载器的用途)</p>

<p>启动:</p>

<ol>
  <li>
    <p>Bootstrap#init</p>

    <ul>
      <li>1.1 设置catalina.home,设置catalina.base (ps: <a href="https://tomcat.apache.org/tomcat-8.0-doc/introduction.html#Directories_and_Files">CATALINA_HOME vs CATALINA_BASE</a>)</li>
      <li>1.2 初始化类加载器,<code class="highlighter-rouge">commonLoader</code>,<code class="highlighter-rouge">catalinaLoader</code>,<code class="highlighter-rouge">sharedLoader</code></li>
      <li>1.3 用catalinaLoader对<code class="highlighter-rouge">org.apache.catalina.startup.Catalina</code>类进行加载,并进行实例化startupInstance,设置catalinaDaemon为startupInstance</li>
      <li>1.4 在bootstrap初始化完毕之后,设置daemon为bootstrap</li>
    </ul>
  </li>
  <li>
    <p>根据传入命令, 已start为例,加载,调用Bootstrap#load(args),实际上是调用catalinaDaemon#load方法</p>

    <ul>
      <li>
        <p>2.1 Catalina#createStartDigester 创建解析规则, 就是创建Server,Service,Executor等元素与相关类的对应关系,根据其配置实例化相应模块,参见<a href="https://github.com/lcj1992/tomcat_study/blob/master/conf/server.xml">server.xml</a>,</p>

        <div class="highlighter-rouge"><pre class="highlight"><code>digester.addObjectCreate("Server","org.apache.catalina.core.StandardServer","className");
digester.addSetProperties("Server");
digester.addSetNext("Server","setServer","org.apache.catalina.Server");
        
digester.addObjectCreate("Server/Listener",null, // MUST be specified in the element(必须在你的server.xml中制定)
                                 "className");
digester.addSetProperties("Server/Listener");
digester.addSetNext("Server/Listener","addLifecycleListener","org.apache.catalina.LifecycleListener");
</code></pre>
        </div>
      </li>
      <li>2.2 读取<code class="highlighter-rouge">$CATALINA_BASE/conf/server.xml</code>,然后解析之,digester#parse(inputSource),会实例化一个Server,并Catalina#setServer指向这个实例,并将Server#setCatalina指向这个Catalina实例.
开始调用StandardServer#initInternal,初始化server实例,初始化时会对状态机进行校验
        <ul>
          <li>globalNamingResources的初始化</li>
          <li>依据我们server.xml中的我们的配置,初始化services(可多个)(StandardService)
            <ul>
              <li>初始化Engine(StandardEngine),创建一个线程池,用于启动和停止服务</li>
              <li>初始化Executors(可多个)(StandardThreadExecutor)</li>
              <li>初始化Connectors(可多个)(Connector)
                <ul>
                  <li>初始化protocolHandler(eg: Http11Protocol)
                    <ul>
                      <li>初始化endpoint(eg JioEndpoint),然后endpoint#bind(),绑定地址和端口,设置线程池的大小,并创建<code class="highlighter-rouge">serverSocket</code> EndPoint的bindState 有UNBOUND -&gt; BOUND_ON_START</li>
                    </ul>
                  </li>
                  <li>初始化mapperListener</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>2.3 启动各组件,还是调用Catalina#start(),启动时都会动状态机进行校验
        <ul>
          <li>globalNamingResources的启动</li>
          <li>启动各services
            <ul>
              <li>启动Engine
                <ul>
                  <li>findChildren() 获取子容器,比如StandardHost的实例,将这些子容器用StartChild类包装成Callable的类，使用线程池启动
                    <ul>
                      <li>child#start() -&gt; (eg)StandardHost#startInternal() -&gt; setState(LifecycleState.STARTING) -&gt; LifecycleBase#setState -&gt; LifecycleBase#setStateInternal -&gt; LifecycleBase#fireLifecycleEvent(LifecycleBase的实现为EngineConfig)
                        <ul>
                          <li>HostConfig#deployApps(deploy configBase的xml文件,war包s,加压后的项目s等)
                            <ul>
                              <li>以DeployWars为例,new一个DeployWar(HostConfig config,ContextName cn,File war),DeployWar实际上是一个runnable,然后将其扔进host.getStartStopExecutor()中</li>
                            </ul>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>启动Executors</li>
              <li>启动connectors
                <ul>
                  <li>启动protocol
                    <ul>
                      <li>启动endpoint,初始化connectionLimitLatch,启动<code class="highlighter-rouge">acce  ptorThreads</code>,启动timeoutThread</li>
                    </ul>
                  </li>
                  <li>启动mapperListener, findDefaultHost(),addListeners(engine),registerHost(host)</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>2.4 如果useShutdownHook为true,添加CatalinaShutdownHook`</li>
      <li>2.5 Catalina#await(),new 一个server socket to wait on (默认端口号为8005,你懂的)</li>
    </ul>
  </li>
</ol>

<h4 id="fsm">状态机</h4>

<p>org.apache.Catalina.Lifecycle的实现类都具有如下的<a href="https://github.com/lcj1992/tomcat_study/blob/master/java/org/apache/catalina/Lifecycle.java">状态机</a>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>             start()
   -----------------------------
   |                           |
   | init()                    |
  NEW -&gt;-- INITIALIZING        |
  | |           |              |     ------------------&lt;-----------------------
  | |           |auto          |     |                                        |
  | |          \|/    start() \|/   \|/     auto          auto         stop() |
  | |      INITIALIZED --&gt;-- STARTING_PREP --&gt;- STARTING --&gt;- STARTED --&gt;---  |
  | |         |                                                  |         |  |
  | |         |                                                  |         |  |
  | |         |                                                  |         |  |
  | |destroy()|                                                  |         |  |
  | --&gt;-----&lt;--       auto                    auto               |         |  |
  |     |       ---------&lt;----- MUST_STOP ---------------------&lt;--         |  |
  |     |       |                                                          |  |
  |    \|/      ---------------------------&lt;--------------------------------  ^
  |     |       |                                                             |
  |     |      \|/            auto                 auto              start()  |
  |     |  STOPPING_PREP ------&gt;----- STOPPING ------&gt;----- STOPPED ----&gt;------
  |     |                                ^                  |  |  ^
  |     |               stop()           |                  |  |  |
  |     |       --------------------------                  |  |  |
  |     |       |                                  auto     |  |  |
  |     |       |                  MUST_DESTROY------&lt;-------  |  |
  |     |       |                    |                         |  |
  |     |       |                    |auto                     |  |
  |     |       |    destroy()      \|/              destroy() |  |
  |     |    FAILED ----&gt;------ DESTROYING ---&lt;-----------------  |
  |     |                        ^     |                          |
  |     |     destroy()          |     |auto                      |
  |     --------&gt;-----------------    \|/                         |
  |                                 DESTROYED                     |
  |                                                               |
  |                            stop()                             |
  ---&gt;------------------------------&gt;------------------------------
</code></pre>
</div>

<ol>
  <li>任何状态都可以过渡到FAILED</li>
  <li>当组件在STARTING_PREP,STARTING,STARTED,调用start()方法是没有作用的</li>
  <li>当组件在NEW状态时调用start()方式会先调用init()</li>
  <li>当组件在STOPPING_PREP,STOPPING,STOPPED调用stop()方法是不起作用的</li>
  <li>当组件从NEW过渡到STOPPED会调用stop()方法.这经常发生在一个组件没有启动起来,并且没有启动他的所有子组件.当一个组件stopped后,它会试着停止所有它的子组件,即使它没有启动起来</li>
  <li>MUST_STOP用来标明从start()中退出后,应该调用stop().这经常用在一个组件启动失败了.</li>
  <li>MUST_DESTROY用来标明从stop()中退出后,应该调用destroy(),这经常用在不需要重启的组件.</li>
  <li>任何别的状态过渡都会抛出LifecycleException</li>
  <li>在调用其中方法时触发状态变更,触发LifecycleEvents</li>
</ol>

<p>Lifecycle的子类类图:</p>

<p><img src="/images/soft/tomcat_lifecycle.png" alt="Lifecycle子类" /></p>

<h4 id="tomcat">tomcat处理请求</h4>

<p><img src="/images/soft/tomcat_handle_request.jpg" alt="tomcat处理请求" /></p>

<p>对于BIO模式,tomcat启动后就是使用JioEndPoint.Acceptor来接收外部请求的socket连接. 启动个tomcat,jstack下,你会发现如下线程栈.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>"http-bio-8080-Acceptor-0" daemon prio=5 tid=0x00007fb583ae0000 nid=0x5503 runnable [0x0000700001555000]
java.lang.Thread.State: RUNNABLE
at java.net.PlainSocketImpl.socketAccept(Native Method)
at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:398)
at java.net.ServerSocket.implAccept(ServerSocket.java:530)
at java.net.ServerSocket.accept(ServerSocket.java:498)
at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket(DefaultServerSocketFactory.java:60)
at org.apache.tomcat.util.net.JIoEndpoint$Acceptor.run(JIoEndpoint.java:216)
at java.lang.Thread.run(Thread.java:745)
</code></pre>
</div>

<p>JioEndpoint的Acceptor是这么产生的,启动<code class="highlighter-rouge">getAcceptorThreadCount()</code>个线程,接收请求.</p>

<blockquote>
  <p>Connector#startInternal() -&gt; AbstractEndpoint#start() -&gt; JIoEndpoint#startInternal() -&gt; AbstractEndpoint#startAcceptorThreads() -&gt; JioEndpoint#createAcceptor()</p>
</blockquote>

<p><img src="/images/soft/create_acceptor.png" alt="create_acceptor" /></p>

<p>其中AbstractEndpoint#start():</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public final void start() throws Exception {
    if (bindState == BindState.UNBOUND) {
        bind();
        bindState = BindState.BOUND_ON_START;
    }
    startInternal();
}

protected final void startAcceptorThreads() {
    int count = getAcceptorThreadCount();
    acceptors = new Acceptor[count];

    for (int i = 0; i &lt; count; i++) {
        acceptors[i] = createAcceptor();
        String threadName = getName() + "-Acceptor-" + i;
        acceptors[i].setThreadName(threadName);
        Thread t = new Thread(acceptors[i], threadName);
        t.setPriority(getAcceptorThreadPriority());
        t.setDaemon(getDaemon());
        t.start();
    }
}
</code></pre>
</div>

<p>接下来就是接收socket,处理socket</p>

<ol>
  <li>countUpAwaitConnection(),如果maxConnections = -1直接返回,否则,acquire 一个共享的latch或者等会</li>
  <li>socket = socket.accept(serverSocket)</li>
  <li>
    <p>processSocket(socket),对于Bio http源码如下:</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>protected boolean processSocket(Socket socket) {
try {
    SocketWrapper&lt;Socket&gt; wrapper = new SocketWrapper&lt;Socket&gt;(socket);
    wrapper.setKeepAliveLeft(getMaxKeepAliveRequests());
    // During shutdown, executor may be null - avoid NPE
    if (!running) {
        return false;
    }
    getExecutor().execute(new SocketProcessor(wrapper));
} catch (RejectedExecutionException x) {
    log.warn("Socket processing request was rejected for:"+socket,x);
    return false;
} catch (Throwable t) {
    ExceptionUtils.handleThrowable(t);
    // This means we got an OOM or similar creating a thread, or that
    // the pool and its queue are full
    log.error(sm.getString("endpoint.process.fail"), t);
    return false;
}
return true;
</code></pre>
    </div>
  </li>
</ol>

<p>然后返回请求, 请求返回的方法调用链:</p>

<ol>
  <li>JIoEndpoint$SocketProcessor#run</li>
  <li>AbstractProtocol$AbstractConnectionHandler#process</li>
  <li>AbstractHttp11Processor#process</li>
  <li>CoyoteAdapter#service</li>
  <li>StandardEngineValve#invoke</li>
  <li>AccessLogValve#invoke</li>
  <li>ErrorReportValve#invoke</li>
  <li>StandardHostValve#invoke</li>
  <li>AuthenticatorBase#invoke</li>
  <li>StandardContextValve#invoke</li>
  <li>StandardWrapperValve#invoke</li>
  <li>ApplicationFilterChain#doFilter</li>
  <li>ApplicationFilterChain#internalDoFilter</li>
  <li>HttpServlet#service 然后调用doGet 或者doPost</li>
</ol>

<p><a href="https://github.com/lcj1992/tomcat_study/blob/master/java/javax/servlet/http/HttpServlet.java">HTTPServlet源码</a></p>

<p>这段日志熟悉不.不熟悉的话,自己写个controller,主动throw个异常</p>

<div class="highlighter-rouge"><pre class="highlight"><code>at com.xx.controller.BookController.order(BookController.java:114) [BookController.class:na]
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_45]
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_45]
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_45]
at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_45]
at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:219) [spring-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132) [spring-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:100) [spring-webmvc-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:604) [spring-webmvc-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:565) [spring-webmvc-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:80) [spring-webmvc-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:923) [spring-webmvc-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:852) [spring-webmvc-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:882) [spring-webmvc-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:778) [spring-webmvc-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at javax.servlet.http.HttpServlet.service(HttpServlet.java:621) [servlet-api.jar:na]
at javax.servlet.http.HttpServlet.service(HttpServlet.java:728) [servlet-api.jar:na]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305) [catalina.jar:7.0.47]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) [catalina.jar:7.0.47]
at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) [tomcat7-websocket.jar:7.0.47]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243) [catalina.jar:7.0.47]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) [catalina.jar:7.0.47]
at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) [spring-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76) [spring-web-3.1.4.RELEASE.jar:3.1.4.RELEASE]
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243) [catalina.jar:7.0.47]
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210) [catalina.jar:7.0.47]
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222) [catalina.jar:7.0.47]
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123) [catalina.jar:7.0.47]
at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:502) [catalina.jar:7.0.47]
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) [catalina.jar:7.0.47]
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:100) [catalina.jar:7.0.47]
at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:953) [catalina.jar:7.0.47]
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118) [catalina.jar:7.0.47]
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408) [catalina.jar:7.0.47]
at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1041) [tomcat-coyote.jar:7.0.47]
at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:603) [tomcat-coyote.jar:7.0.47]
at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:310) [tomcat-coyote.jar:7.0.47]
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [na:1.7.0_45]
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [na:1.7.0_45]
at java.lang.Thread.run(Thread.java:744) [na:1.7.0_45]
</code></pre>
</div>

<h4 id="ref">参考</h4>

<p>[tomcat8官方文档]<a href="https://tomcat.apache.org/tomcat-8.0-doc/config/service.html">https://tomcat.apache.org/tomcat-8.0-doc/config/service.html</a></p>

<p>[tomcat的启动和关闭]<a href="http://yikebocai.com/2014/11/tomcat-source-code-study-2/">http://yikebocai.com/2014/11/tomcat-source-code-study-2/</a></p>

<p>[tomcat处理请求]<a href="http://yikebocai.com/2014/11/tomcat-source-code-study-3/">http://yikebocai.com/2014/11/tomcat-source-code-study-3/</a></p>

<p>[tomcat处理HTTP请求源码分析]<a href="http://www.infoq.com/cn/articles/zh-tomcat-http-request-1">http://www.infoq.com/cn/articles/zh-tomcat-http-request-1</a></p>

        <ul class="prev_next">
            
            <li>
                <span>上一篇</span>
                <a href="/2016/04/09/method">方法</a>
            </li>
            
            
            <li>
                <span>下一篇</span>
                <a href="/2016/04/29/airline_av">airlineAv调优记</a>
            </li>
            
        </ul>
        <div class="ds-share flat" data-thread-key="/2016/04/26/tomcat_source" data-title="tomcat的启动关闭与请求处理"
             data-url="http://lcj1992.github.io/2016/04/26/tomcat_source">
            <div class="ds-share-inline">
                <ul class="ds-share-icons-16">

                    <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
                    <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
                    <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

                </ul>
                <div class="ds-share-icons-more">
                </div>
            </div>
        </div>
        <div class="ds-thread" data-thread-key="/2016/04/26/tomcat_source" data-title="tomcat的启动关闭与请求处理"
             data-url="http://lcj1992.github.io/2016/04/26/tomcat_source"></div>
        <!-- 多说评论框 end -->
        <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
        <script type="text/javascript">
            var duoshuoQuery = {short_name: "lcj1992"};
            (function () {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';
                ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>

        <!-- jQuery -->
        <script src="/js/jquery.js"></script>

        <!-- Bootstrap Core JavaScript -->
        <script src="/js/bootstrap.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="/js/codeboy.js"></script>

        <script src="/js/bootstrap3-typeahead.js"></script>
        <script src="/js/jquery.hotkeys.js"></script>
        <script>
            (function (i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r;
                i[r] = i[r] || function () {
                            (i[r].q = i[r].q || []).push(arguments)
                        }, i[r].l = 1 * new Date();
                a = s.createElement(o),
                        m = s.getElementsByTagName(o)[0];
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m)
            })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-72949519-1', 'auto');
            ga('send', 'pageview');

        </script>

        <!-- TODO: only load in tag.html -->
        <script src="/js/jquery.tagcloud.js" type="text/javascript" charset="utf-8"></script>
        <script language="javascript">
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'}
            };
            $(function () {
                $('#tag_cloud a').tagcloud();
            });
        </script>

        <!-- async load function -->
        <script>
            function async(u, c) {
                var d = document, t = 'script',
                        o = d.createElement(t),
                        s = d.getElementsByTagName(t)[0];
                o.src = u;
                if (c) {
                    o.addEventListener('load', function (e) {
                        c(null, e);
                    }, false);
                }
                s.parentNode.insertBefore(o, s);
            }
        </script>

        <!-- Highlight.js -->
        <script>
            async("https://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () {
                hljs.initHighlightingOnLoad();
            })
        </script>
        <link href="https://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">


        <script>
            $(document).ready(function () {
                var time1 = 0;
                var show = false;
                var names = new Array(); //文章名字等
                var urls = new Array(); //文章地址
                $(document).keyup(function (e) {
                    var time2 = new Date().getTime();
                    if (e.keyCode == 17) {
                        var gap = time2 - time1;
                        time1 = time2;
                        if (gap < 500) {
                            if (show) {
                                $(".search-tool").css("display", "none");
                                show = false;
                            } else {
                                $(".search-tool").css("display", "block");
                                show = true;
                                $("#search-content").val("");
                                $("#search-content").focus();
                            }
                            time1 = 0;
                        }
                    } else if (e.keyCode == 27) {
                        $(".search-tool").css("display", "none");
                        show = false;
                        time1 = 0;
                    }
                });

                $("#search-content").keyup(function (e) {
                    var time2 = new Date().getTime();
                    if (window.event.keyCode == 17) {
                        var gap = time2 - time1;
                        time1 = time2;
                        if (gap < 500) {
                            if (show) {
                                $(".search-tool").css("display", "none");
                                show = false;
                            } else {
                                $(".search-tool").css("display", "block");
                                show = true;
                                $("#search-content").val("");
                                $("#search-content").focus();
                            }
                            time1 = 0;
                        }
                    }
                });

                $("#close-btn").click(function () {
                    $(".search-tool").css("display", "none");
                    show = false;
                    time1 = 0;
                });

                $("#search-btn").click(function () {
                    $(".search-tool").css("display", "block");
                    show = true;
                    $("#search-content").val("");
                    $("#search-content").focus();
                    time1 = 0;
                });
                // 家目录快捷键
                $(document).bind('keydown', 'alt+h', function () {
                    window.location.href = "/";
                });
                // 目录快捷键
                $(document).bind('keydown', 'alt+c', function () {
                    window.location.href = "/categories.html";
                });
                // 书单快捷键
                $(document).bind('keydown', 'alt+b', function () {
                    window.location.href = "/booklist.html";
                });
                // 个人介绍页快捷键
                $(document).bind('keydown', 'alt+a', function () {
                    window.location.href = "/about.html";
                });
                // 上一篇
                $(document).bind('keydown', 'alt+p', function () {
                    window.location.href = "/2016/04/09/method";
                });
                // 下一篇
                $(document).bind('keydown', 'alt+n', function () {
                    window.location.href = "/2016/04/29/airline_av";
                });

                $.getJSON("/search.json").done(function (data) {
                    if (data.code == 0) {
                        for (var index in data.data) {
                            var item = data.data[index];
                            names.push(item.title);
                            urls.push(item.url);
                        }

                        $("#search-content").typeahead({
                            source: names,

                            afterSelect: function (item) {
                                $(".search-tool").css("display", "none");
                                show = false;
                                window.location.href = (urls[names.indexOf(item)]);
                                return item;
                            }
                        });
                    }
                });

            });
        </script>

        <style>
            @media screen and (min-width: 768px) {
                .dropdown-menu {
                    float: none;
                    font-size: 20px;
                    width: 70%;
                    margin: 0 15%;
                }

                .search-tool ul {
                    width: 70%;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                .search-content {
                    width: 70%;
                    margin: 0 15%;
                    position: absolute;
                    top: 13%;
                    left: auto;
                    right: auto;
                    font-size: 22px;
                    height: 50px;
                    background-color: #eee;
                    color: black;
                    opacity: 1.0;
                }
            }

            @media screen and (max-width: 767px) {
                .dropdown-menu {
                    float: none;
                    font-size: 20px;
                    width: 96%;
                    margin: 0 2%;
                }

                .search-tool ul {
                    width: 96%;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                .search-content {
                    width: 96%;
                    margin: 0 2%;
                    position: absolute;
                    top: 10%;
                    left: auto;
                    right: auto;
                    font-size: 22px;
                    height: 50px;
                    background-color: #eee;
                    color: black;
                    opacity: 1.0;
                }
            }
        </style>
        <div class="search-tool" style="position: fixed; top: 0px ; bottom: 0px; left: 0px; right:  0px;
      opacity: 0.95; background-color: #111111; z-index: 9999; display: none;">
            <input type="text" class="form-control search-content" id="search-content" placeholder="文章标题 日期 标签">

            <div style="position: fixed; top: 16px; right: 16px;">
                <img src="/images/search/close.png" id="close-btn"/>
            </div>
        </div>

        <div style="position: fixed; right: 12px; top: 50%;bottom: 50%;">
            <img src="/images/search/search.png" id="search-btn" title="双击ctrl试一下"/>
        </div>

    </div>
</div>
</body>
</html>


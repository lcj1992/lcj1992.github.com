<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="baidu-site-verification" content="vuaTJrjFLn" />
    <meta name="keywords" content="foolchild,linux,java,技术,互联网" />
    <meta name="description" content="技术博客，记录foolchild技术道路上成长的点滴" />
    <title> 一条sql的执行（mysql）  </title>
    <link rel="stylesheet" href="/css/default.css" type="text/css"/>
    <link rel="stylesheet" href="/css/small.css" type="text/css" media="(max-width: 720px)"/>
    <link rel="stylesheet" href="/css/syntax.css" type="text/css"/>
    <link rel="stylesheet" href="/css/bootstrap.css" type="text/css"/>
    <link rel="stylesheet" href="/css/codeboy.css" type="text/css"/>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
</head>
<body>
<div id="container">
    <div class="nav">
    <div class="nav_nav">
        <a href="/">首页</a>
        <a href="/categories.html">目录</a>
        <a href="/booklist.html">书单</a>
        <a href="/about.html">关于</a>
    </div>
</div>

    <div id="main">
        <h2> 一条sql的执行（mysql） </h2>
        <ul>
  <li><a href="#select">select sql执行顺序</a>
    <ul>
      <li><a href="#sql">细解</a></li>
    </ul>
  </li>
  <li><a href="#explain">explain</a>
    <ul>
      <li><a href="#explain_result">explain输出字段说明</a>
        <ul>
          <li><a href="#select_type">select_type说明</a></li>
          <li><a href="#table">table列说明</a></li>
          <li><a href="#type">type列说明</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#ds">索引的数据结构</a></li>
  <li><a href="#how_where">where条件在数据库中提取</a></li>
  <li><a href="#case">case</a></li>
</ul>

<h2 id="select">select sql执行顺序</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>    (8)SELECT (9)DISTINCT
    &lt;select_list&gt;
    (1)FROM &lt;left_table&gt;
    (3)　&lt;join_type&gt; JOIN &lt;right_table&gt;
    (2)　 ON &lt;join_condition&gt;  
    (4)WHERE &lt;where_condition&gt;
    (5)GROUP BY &lt;group_by_list&gt;
    (6)WITH {CUBE | ROLLUP}
    (7)HAVING &lt;having_condition&gt;
    (10)ORDER BY &lt;order_by_list&gt;
    (11)&lt;LIMIT_specification&gt;
</code></pre>
</div>

<p>执行顺序:</p>

<p><code class="highlighter-rouge">笛卡尔积---on---join类型---where---group by---with{cube | rollup}---having---select---distinct---order by---limit</code></p>

<p>ps:</p>

<p>limit works on MySQL and PostgreSQL, top works on SQL Server, rownum works on Oracle.</p>

<h3 id="sql">细解</h3>

<ol>
  <li>
    <p>on vs where
两者效果可能一样，但on是连接两表做笛卡尔积时的连接条件，where连接之后的筛选条件。</p>
  </li>
  <li>
    <p>where vs having</p>

    <ol>
      <li>
        <p>where 在对查询结果进行分组前(<code class="highlighter-rouge">group by 之前</code>)，将不符合where条件的行去掉，即在分组之前过滤数据， <strong><em>where条件中不能包含聚集函数</em></strong>，使用where条件过滤出特定的行。</p>
      </li>
      <li>
        <p>having 筛选满足条件的组(<code class="highlighter-rouge">group by 之后</code>,having是专门搭配group by干活的)，即在分组之后过滤数据，条件中经常包含聚集函数，使用having条件过滤出特定的组，也可以使用多个分组标准进行分组。</p>
      </li>
    </ol>
  </li>
  <li>
    <p>join、left join、right join　　
eg table_a,table_b</p>

    <ol>
      <li>left join 以左为准，右可以为空, 记录数&gt;=table_a总数</li>
      <li>right join 以右为准，左可以为空，记录数&gt;=table_b总数</li>
    </ol>
  </li>
  <li>
    <p>group by</p>

    <ol>
      <li>
        <p>先对某一列或多列进行分组，然后在分组内进行相应的操作，一般和count，max等聚集函数一起使用。</p>
      </li>
      <li>
        <p>聚集函数与列不能同时出现在select子句中，除非这个列是group by子句的分组列,参见下错误例子</p>
      </li>
      <li>
        <p>当查询语句中有group by子句时，聚集函数作用的对象是一个分组，而不是整个查询的结果,没有group by的话是整个查询结果</p>

        <p>select DepartmentId,Name,count(Salary) from Employee group by Name;</p>

        <p>Error Code: 1055. Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column ‘test.Employee.DepartmentId’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</p>
      </li>
    </ol>
  </li>
  <li>
    <p>order by</p>

    <p>对某一列进行排序,发生在select，distinct之后</p>
  </li>
  <li>
    <p>limit</p>

    <p>取出结果的几个 eg：limit 1,2从1开始的2个。  查询结果是从0 开始的,db会扫出这n＋m条记录，然后筛选。所以分页慎用limit m,n</p>
  </li>
  <li>
    <p>union和union all</p>

    <p>跨库查询，union会去重，union all 不会去重</p>
  </li>
</ol>

<h2 id="explain">执行计划</h2>

<p>explain来解释和分析sql查询语句</p>

<div class="highlighter-rouge"><pre class="highlight"><code>explain extended format=traditional select * from mtp_book_id in (select max(book_id) from book_goods_info order by id)
</code></pre>
</div>

<p><img src="/images/database/explain.png" alt="explain" /></p>

<p>ps:
1.  format有traditional 和json两种格式
2.  认为增加explain时mysql不会执行查询，这是错误的。实际上如果查询在from自居中包含子查询，mysql实际上是会执行子查询的。
3.  explain只是个近似的结果</p>

<h3 id="explain_result">explain输出字段说明</h3>

<table>
  <thead>
    <tr>
      <th>字段</th>
      <th>对应json格式的key</th>
      <th>含义</th>
      <th>备注</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>select_id</td>
      <td>查询语句的id</td>
      <td>mysql按照id从小到大的顺序进行解释，实际上执行是按照id从大到小的顺序</td>
    </tr>
    <tr>
      <td>select_type</td>
      <td>none</td>
      <td>select的类型</td>
      <td>select查询分为简单和复杂类型，复杂类型可分为三大类：简单子查询、派生表（在from子句中的子查询）、union查询，详见<a href="#select_type">select_type说明</a></td>
    </tr>
    <tr>
      <td>table</td>
      <td>table_name</td>
      <td>显示对应行正砸访问哪张表</td>
      <td>可以是一张表，一个子查询、一个union结果。详见<a href="#table">table说明</a></td>
    </tr>
    <tr>
      <td>partitions</td>
      <td>partitions</td>
      <td>匹配到的分区</td>
      <td> </td>
    </tr>
    <tr>
      <td>type</td>
      <td>access_type</td>
      <td><strong>mysql手册上说这一列是关联类型，但我们认为更准确的说法是访问类型</strong>，参见<em>高性能mysql 3th p695</em>，我也觉得这样说比较合适</td>
      <td>详见<a href="#type">type说明</a></td>
    </tr>
    <tr>
      <td>possible_keys</td>
      <td>possiable_keys</td>
      <td>可能会选择的索引</td>
      <td>这是基于查询访问的列和使用的比较操作符来判断的，这个列表是在优化过程中早起创建的，因此罗列出来的索引可能对于后续优化过程是没用的</td>
    </tr>
    <tr>
      <td>key</td>
      <td>key</td>
      <td>真实选择的索引</td>
      <td>显示的是mysql实际使用的索引</td>
    </tr>
    <tr>
      <td>key_len</td>
      <td>key_length</td>
      <td>选择的索引的长度</td>
      <td>mysql决定使用的索引的长度</td>
    </tr>
    <tr>
      <td>ref</td>
      <td>ref</td>
      <td>与索引进行比较的列数</td>
      <td> </td>
    </tr>
    <tr>
      <td>rows</td>
      <td>rows</td>
      <td>被检查的记录数的估量</td>
      <td>rows是核心指标，绝大部分rows小的语句执行一定很快（有例外),所以优化语句基本上都是在优化rows。</td>
    </tr>
    <tr>
      <td>filtered</td>
      <td>filtered</td>
      <td>被查询条件过滤的记录数的占比</td>
      <td>5.7.3之前extended才会显示,总是100%！？参见<a href="http://blog.chinaunix.net/uid-20726500-id-5573764.html">总是100%</a></td>
    </tr>
    <tr>
      <td>Extra</td>
      <td>none</td>
      <td>额外信息</td>
      <td>using index 使用覆盖索引；using where 使用where过滤</td>
    </tr>
  </tbody>
</table>

<h4 id="select_type">select_type说明</h4>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>对应json格式的key</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>simple</td>
      <td>none</td>
      <td><code class="highlighter-rouge">简单的查询（没有使用union或者子查询）</code></td>
    </tr>
    <tr>
      <td>primary</td>
      <td>none</td>
      <td><code class="highlighter-rouge">最外层的select（有子查询或者union时）</code></td>
    </tr>
    <tr>
      <td>union</td>
      <td>none</td>
      <td>多个union时，第二个和更后的select</td>
    </tr>
    <tr>
      <td>union result</td>
      <td>union_result</td>
      <td><code class="highlighter-rouge">从union的匿名临时表检索结果的select被标记为union result</code></td>
    </tr>
    <tr>
      <td>subquery</td>
      <td>none</td>
      <td><code class="highlighter-rouge">包含在select列表中的子查询中的select（不再from子句中）</code></td>
    </tr>
    <tr>
      <td>derived</td>
      <td>none</td>
      <td><code class="highlighter-rouge">包含在from子句中的select，mysql会递归执行并将结果放到一个临时表中，服务器内部称其为‘派生表’，因为该临时表是从子查询中派生来的</code></td>
    </tr>
    <tr>
      <td>materialized</td>
      <td>materialized_from_subquery</td>
      <td> </td>
    </tr>
    <tr>
      <td>dependent subquery</td>
      <td>dependent(true)</td>
      <td>类subquery，依赖于外层查询</td>
    </tr>
    <tr>
      <td>dependent union</td>
      <td>dependent(true)</td>
      <td>类union，依赖于外层的查询</td>
    </tr>
    <tr>
      <td>uncacheable subquery</td>
      <td>cacheable (false)</td>
      <td> </td>
    </tr>
    <tr>
      <td>uncacheable union</td>
      <td>cacheable (false)</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>ps:
1.  denpendent: select依赖于外层查询中的数据（你就看你的sql单拿出来，是否可以执行）。
2.  uncacheable: select中的某些特性阻止结果被缓存在一个Item_cache中（Item_cache未被文档记载，它与查询缓存不是一回事，尽管它可以被一些相同类型的构件否定，例如RAND()函数）
3.  针对select，不出意外的话，应该是你的sql中有多少个select，explain你的sql，就会有多少行，每个select都对应有自己的select_type。</p>

<h4 id="table">table列说明</h4>

<p>M，N都是explain结果中的id字段值</p>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">&lt;unionM,N&gt;</code></td>
      <td>当select type为union result，table列为参与union的id列表，总是<code class="highlighter-rouge">向后引用</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">&lt;derivedN&gt;</code></td>
      <td>第n行的派生表的select</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">&lt;subqueryN&gt;</code></td>
      <td>The row refers to the result of a materialized subquery for the row with an id value of N</td>
    </tr>
  </tbody>
</table>

<h4 id="type">type</h4>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>含义</th>
      <th>备注</th>
      <th>case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>system</td>
      <td>表只有一行（系统表），这是const的特殊情形</td>
      <td>todo??</td>
      <td> </td>
    </tr>
    <tr>
      <td>const</td>
      <td>表至多匹配一行，用于和主键或者unique index比较时。</td>
      <td> </td>
      <td><code class="highlighter-rouge">SELECT * FROM tbl_name WHERE primary_key=1;</code></td>
    </tr>
    <tr>
      <td>eq_ref</td>
      <td>索引访问（索引查找）</td>
      <td>表至多匹配一条记录，用于primary key或者unique not null索引</td>
      <td><code class="highlighter-rouge">SELECT * FROM ref_table,other_table WHERE ref_table.key_column=other_table.column;</code></td>
    </tr>
    <tr>
      <td>ref</td>
      <td>索引访问</td>
      <td>匹配的不是一个记录，而是一些记录，访问只有当使用非唯一性索引或者唯一索引的非唯一性前缀时才会发生</td>
      <td><code class="highlighter-rouge">SELECT * FROM ref_table WHERE key_column=expr;</code></td>
    </tr>
    <tr>
      <td>ref_or_null</td>
      <td>类似ref，多了个null</td>
      <td> </td>
      <td><code class="highlighter-rouge">SELECT * FROM ref_table WHERE key_column=expr OR key_column IS NULL;</code></td>
    </tr>
    <tr>
      <td>range</td>
      <td>范围扫描</td>
      <td>有限制的索引扫描，使用操作符<code class="highlighter-rouge">=, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, or IN()</code>、与常量进行比较 ，使用索引列表去查找一系列值，例如in（）和or列表们也会显示范围查询，但访问性能有重要的差异，开销跟索引类型相当</td>
      <td><code class="highlighter-rouge">SELECT * FROM tbl_name WHERE key_column = 10;</code>  <code class="highlighter-rouge">SELECT * FROM tbl_name WHERE key_column BETWEEN 10 and 20;</code></td>
    </tr>
    <tr>
      <td>index</td>
      <td>全索引扫描</td>
      <td>类全表扫描，只是msyql扫描表时按照索引次序进行，而不是行。优点是避免了排序，缺点是要承担按索引读取整个表的开销。当查询结果可以被索引包含时，只扫描索引的数据，而不是按索引次序的每一行，这时Extra列会有<code class="highlighter-rouge">using index</code>标示（<code class="highlighter-rouge">覆盖索引</code>）</td>
      <td> </td>
    </tr>
    <tr>
      <td>all</td>
      <td>全表扫描</td>
      <td>通常意味着mysql必须扫描整张表,也有例外，例如在查询中使用了limit，或者在Extra列显示<code class="highlighter-rouge">using distinct/not exists</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>fulltext</td>
      <td>处理fulltext索引时</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>index_merge</td>
      <td>访问使用了索引合并优化</td>
      <td>todo</td>
      <td> </td>
    </tr>
    <tr>
      <td>unique_subquery</td>
      <td>类似eq_ref，只不过不是＝，而是in</td>
      <td> </td>
      <td><code class="highlighter-rouge">value IN (SELECT primary_key FROM single_table WHERE some_expr)</code></td>
    </tr>
    <tr>
      <td>index_subquery</td>
      <td>类似unique_subquery,只不过作用于非unique索引</td>
      <td> </td>
      <td><code class="highlighter-rouge">value IN (SELECT key_column FROM single_table WHERE some_expr)</code></td>
    </tr>
  </tbody>
</table>

<p>注：</p>

<ol>
  <li><code class="highlighter-rouge">覆盖索引</code>(Covering Index)：只用到某个索引，且该索引包含查询需要的数据列，也就没有回表操作。</li>
  <li>覆盖索引必须要存储索引列的值，而哈希索引、空间索引、和全文索引都不能存储列的值，所以MySQL只能使用B-Tree索引做覆盖索引</li>
</ol>

<h2 id="ds">索引的数据结构</h2>

<p>myisam</p>

<p><img src="/images/database/myisam_pri.png" alt="myisam_pri" /></p>

<ol>
  <li>使用<a href="https://en.wikipedia.org/wiki/B%2B_tree">b＋树</a></li>
  <li><strong>索引文件和数据文件是分离的。</strong> 索引文件仅保存数据记录的地址，索引的叶子节点的data域存放的是数据记录的地址
(上图<code class="highlighter-rouge">标红1处</code>key为15的叶子节点，只保存数据域的指针0x07,标红2处,是存放数据记录的位置)</li>
  <li><strong>主索引和二级索引结构上没有任何差别，只是主索引要求key必须是唯一的</strong></li>
</ol>

<p>innodb</p>

<p><img src="/images/database/innodb_pri.png" alt="innodb_pri" />
<img src="/images/database/innodb_second.png" alt="innodb_second" /></p>

<ol>
  <li>同样是b+树</li>
  <li>数据文件同样是索引文件，数据文件本身就是按B+Tree组织的一个索引结构，叶子节点data域保存完整的数据记录(primary key图中<code class="highlighter-rouge">标红1处</code>,key为15的叶子节点，数据域就是数据记录)，这个索引的key是数据表的主键，因此innodb的表数据文件本身就是主索引。</li>
  <li>innodb主索引，叶节点包含了完整的数据记录，这种索引叫做<code class="highlighter-rouge">聚集索引</code></li>
  <li>innodb的辅助索引data域存储相应记录主键的值而不是数据记录的地址（<code class="highlighter-rouge">标红2处</code>,以col3建了个索引，key为col3，value是其对应的主键）。</li>
  <li>联合索引和最左前缀匹配</li>
  <li>主键不一定是一个字段哟！</li>
</ol>

<p>ps: 因为innodb的数据文件本身要按主键聚集，所以innodb要求表必须有主键（myisam可以没有），如果没有显式指定，则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则mysql自动为innodb表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>

<h2 id="how_where">where条件在数据库中提取</h2>

<p>SQL语句中的where条件，使用以上的提取规则，最终都会被提取到<code class="highlighter-rouge">Index Key</code> (<code class="highlighter-rouge">First Key</code> &amp; <code class="highlighter-rouge">Last Key</code>)，<code class="highlighter-rouge">Index Filter</code>与<code class="highlighter-rouge">Table Filter</code>之中。</p>

<ol>
  <li>Index Key
    <ol>
      <li>Index First Key，只是用来定位索引的起始范围，因此只在索引第一次Search Path(沿着索引B+树的根节点一直遍历，到索引正确的叶节点位置)时使用，一次判断即可，
        <ol>
          <li>从索引的第一个键值开始，检查其在where条件中是否存在，若存在并且条件是=，则将对应的条件加入Index First Key之中，继续读取索引的下一个键值，使用同样的提取规则</li>
          <li>若存在并且条件是&gt;=或者&gt;，则将对应的条件加入Index First Key中，同时终止Index First Key的提取；若不存在，同样终止Index First Key的提取。</li>
        </ol>
      </li>
      <li>Index Last Key，用来定位索引的终止范围，因此对于起始范围之后读到的每一条索引记录，均需要判断是否已经超过了Index Last Key的范围，若超过，则当前查询结束；
        <ol>
          <li>从索引的第一个键值开始，检查其在where条件中是否存在，若存在并且条件是=，则将对应条件加入到Index Last Key中，继续提取索引的下一个键值，使用同样的提取规则</li>
          <li>若存在并且条件是 &lt;或&lt;= ，则将条件加入到Index Last Key中，同时终止提取；若不存在，同样终止Index Last Key的提取。</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <p>Index Filter
用于过滤索引查询范围中不满足查询条件的记录，因此对于索引范围中的每一条记录，均需要与Index Filter进行对比，若不满足Index Filter则直接丢弃，继续读取索引下一条记录；
    1.  从索引列的第一列开始，检查其在where条件中是否存在：若存在并且where条件仅为 =，则跳过第一列继续检查索引下一列，下一索引列采取与索引第一列同样的提取规则
    2.  若where条件为 &gt;=、&gt;、&lt;、&lt;= 其中的几种，则跳过索引第一列，将其余where条件中索引相关列全部加入到Index Filter之中
    3.  若索引第一列的where条件包含 =、&gt;=、&gt;、&lt;、&lt;= 之外的条件，则将此条件以及其余where条件中索引相关列全部加入到Index Filter之中
    4.  若第一列不包含查询条件，则将所有索引相关条件均加入到Index Filter之中。</p>
  </li>
  <li>Table Filter
最后一道where条件的防线，用于过滤通过前面索引的层层考验的记录，此时的记录已经满足了Index First Key与Index Last Key构成的范围，并且满足Index Filter的条件，回表读取了完整的记录，判断完整记录是否满足Table Filter中的查询条件，同样的，若不满足，跳过当前记录，继续读取索引的下一条记录，若满足，则返回记录，此记录满足了where的所有条件，可以返回给前端用户。</li>
</ol>

<h2 id="case">case</h2>
<p>case1:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mysql&gt; explain select * from mtp_book_info order by book_id desc limit 10000,10;
+----+-------------+---------------+-------+---------------+---------+---------+------+-------+-------+
| id | select_type | table         | type  | possible_keys | key     | key_len | ref  | rows  | Extra |
+----+-------------+---------------+-------+---------------+---------+---------+------+-------+-------+
|  1 | SIMPLE      | mtp_book_info | index | NULL          | PRIMARY | 4       | NULL | 10010 |       |
+----+-------------+---------------+-------+---------------+---------+---------+------+-------+-------+
1 row in set (0.05 sec)
</code></pre>
</div>

<ol>
  <li>没有子查询和union，所以select_type为simple</li>
  <li>type为index,表明为索引扫描，扫描索引数，然后回表拿数据</li>
  <li>book_id 为primary key</li>
  <li>book_id类型为int，字节长度为4</li>
  <li>从10000到10010，但mysql需要读取前10010，然后截取10000-10010? 存疑！</li>
</ol>

<p>case2:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mysql&gt; explain select  * from mtp_book_info where book_id &gt;= (select book_id from mtp_book_info
order by book_id  desc limit 10000, 1) order by book_id desc  limit 10;  
+----+-------------+---------------+-------+---------------+---------+---------+------+-------+-------------+
| id | select_type | table         | type  | possible_keys | key     | key_len | ref  | rows  | Extra       |
+----+-------------+---------------+-------+---------------+---------+---------+------+-------+-------------+
|  1 | PRIMARY     | mtp_book_info | range | PRIMARY       | PRIMARY | 4       | NULL | 19764 | Using where |
|  2 | SUBQUERY    | mtp_book_info | index | NULL          | PRIMARY | 4       | NULL | 10001 | Using index |
+----+-------------+---------------+-------+---------------+---------+---------+------+-------+-------------+
2 rows in set (0.04 sec)
</code></pre>
</div>

<ol>
  <li>解释是按照id从小到大开始解释的，执行是从大到小。</li>
  <li>有子查询，且不在from，join子句中，所以2的select_type是subquery，而不是derived</li>
  <li>id为2: type为index，且Extra为Using index表明使用了覆盖索引优化,索引树中包含所有select的数据，所以就不需要回表拿数据了</li>
  <li>id为1: 使用了book_id索引，且使用了&gt;=,所以为range，</li>
  <li>id为1: 使用了where条件，所以Extra中有Using where</li>
  <li>id为1: rows 19764 ？ todo</li>
</ol>

<p>case3:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mysql&gt; explain select * from mtp_book_info as book1 join (select book_id from mtp_book_info
order by book_id desc limit 10000, 10) as book2 where  book1.book_id = book2.book_id ;
+----+-------------+---------------+--------+---------------+---------+---------+---------------+-------+-------------+
| id | select_type | table         | type   | possible_keys | key     | key_len | ref           | rows  | Extra       |
+----+-------------+---------------+--------+---------------+---------+---------+---------------+-------+-------------+
|  1 | PRIMARY     | &lt;derived2&gt;    | ALL    | NULL          | NULL    | NULL    | NULL          |    10 |             |
|  1 | PRIMARY     | book1         | eq_ref | PRIMARY       | PRIMARY | 4       | book2.book_id |     1 |             |
|  2 | DERIVED     | mtp_book_info | index  | NULL          | PRIMARY | 4       | NULL          | 10010 | Using index |
+----+-------------+---------------+--------+---------------+---------+---------+---------------+-------+-------------+
3 rows in set (0.03 sec)
</code></pre>
</div>

<ol>
  <li>id为2: join子句，所以select_type为derived</li>
  <li>id为2: 覆盖索引，case2</li>
  <li>id为1: 都是最外层的select，所以select_type为primary</li>
  <li>id为1的第一个:因为对于派生表来说，book_id只是一个普通字段，所以其type为all，需要进行全表扫描</li>
  <li>id为1的第二个:book_id为mtp_book_info的主键，又使用的是＝，对于每个主键，至多又一条记录，所以type为all</li>
</ol>

<p>case4:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mysql&gt; explain select order_display_id from mtp_book_info  union all select order_display_id from book_goods_info;
+----+--------------+-----------------+-------+---------------+----------------------+---------+------+-------+-------------+
| id | select_type  | table           | type  | possible_keys | key                  | key_len | ref  | rows  | Extra       |
+----+--------------+-----------------+-------+---------------+----------------------+---------+------+-------+-------------+
|  1 | PRIMARY      | mtp_book_info   | index | NULL          | idx_order_display_id | 8       | NULL | 64174 | Using index |
|  2 | UNION        | book_goods_info | index | NULL          | idx_order_display_id | 8       | NULL | 64147 | Using index |
| NULL | UNION RESULT | &lt;union1,2&gt;      | ALL   | NULL          | NULL                 | NULL    | NULL |  NULL |             |
+----+--------------+-----------------+-------+---------------+----------------------+---------+------+-------+-------------+
3 rows in set (0.04 sec)
</code></pre>
</div>

<ol>
  <li>id为2: 多个union时，第二个和更后的select,select_type为union</li>
  <li>id为null: union result 参与union的两张表为id为1和2的select结果</li>
</ol>

<h2 id="ref">参考</h2>

<p>[mysql explain详解]<a href="http://www.cnitblog.com/aliyiyi08/archive/2016/04/21/48878.html">http://www.cnitblog.com/aliyiyi08/archive/2016/04/21/48878.html</a></p>

<p>[官方文档]<a href="https://dev.mysql.com/doc/">https://dev.mysql.com/doc/</a></p>

<p>[MySQL索引背后的数据结构及算法原理]<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>

<p>[《高性能MySQL》读书笔记－－索引]<a href="http://blog.csdn.net/xifeijian/article/details/20312557">http://blog.csdn.net/xifeijian/article/details/20312557</a></p>

<p>[MySQL索引原理及慢查询优化]<a href="http://tech.meituan.com/mysql-index.html">http://tech.meituan.com/mysql-index.html</a></p>

<p>[Innodb页面存储结构-1]<a href="http://tencentdba.com/blog/innodb%E9%A1%B5%E9%9D%A2%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1/">http://tencentdba.com/blog/innodb%E9%A1%B5%E9%9D%A2%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-1/</a></p>

<p>[Innodb页面存储结构-2]<a href="http://tencentdba.com/blog/innodb%E9%A1%B5%E9%9D%A2%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-2/">http://tencentdba.com/blog/innodb%E9%A1%B5%E9%9D%A2%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-2/</a></p>

        <ul class="prev_next">
            
            <li>
                <span>上一篇</span>
                <a href="/2016/07/10/hello_kafka">Hello_kafka</a>
            </li>
            
            
            <li>
                <span>下一篇</span>
                <a href="/2016/07/16/transaction">事务隔离级</a>
            </li>
            
        </ul>
        <div class="ds-share flat" data-thread-key="/2016/07/16/mysql_explain" data-title="一条sql的执行（mysql）"
             data-url="http://lcj1992.github.io/2016/07/16/mysql_explain">
            <div class="ds-share-inline">
                <ul class="ds-share-icons-16">

                    <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
                    <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
                    <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

                </ul>
                <div class="ds-share-icons-more">
                </div>
            </div>
        </div>
        <div class="ds-thread" data-thread-key="/2016/07/16/mysql_explain" data-title="一条sql的执行（mysql）"
             data-url="http://lcj1992.github.io/2016/07/16/mysql_explain"></div>
        <!-- 多说评论框 end -->
        <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
        <script type="text/javascript">
            var duoshuoQuery = {short_name: "lcj1992"};
            (function () {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';
                ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>

        <!-- jQuery -->
        <script src="/js/jquery.js"></script>

        <!-- Bootstrap Core JavaScript -->
        <script src="/js/bootstrap.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="/js/codeboy.js"></script>

        <script src="/js/bootstrap3-typeahead.js"></script>
        <script src="/js/jquery.hotkeys.js"></script>
        <script>
            (function (i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r;
                i[r] = i[r] || function () {
                            (i[r].q = i[r].q || []).push(arguments)
                        }, i[r].l = 1 * new Date();
                a = s.createElement(o),
                        m = s.getElementsByTagName(o)[0];
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m)
            })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-72949519-1', 'auto');
            ga('send', 'pageview');

        </script>

        <!-- TODO: only load in tag.html -->
        <script src="/js/jquery.tagcloud.js" type="text/javascript" charset="utf-8"></script>
        <script language="javascript">
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'}
            };
            $(function () {
                $('#tag_cloud a').tagcloud();
            });
        </script>

        <!-- async load function -->
        <script>
            function async(u, c) {
                var d = document, t = 'script',
                        o = d.createElement(t),
                        s = d.getElementsByTagName(t)[0];
                o.src = u;
                if (c) {
                    o.addEventListener('load', function (e) {
                        c(null, e);
                    }, false);
                }
                s.parentNode.insertBefore(o, s);
            }
        </script>

        <!-- Highlight.js -->
        <script>
            async("https://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () {
                hljs.initHighlightingOnLoad();
            })
        </script>
        <link href="https://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">


        <script>
            $(document).ready(function () {
                var time1 = 0;
                var show = false;
                var names = new Array(); //文章名字等
                var urls = new Array(); //文章地址
                $(document).keyup(function (e) {
                    var time2 = new Date().getTime();
                    if (e.keyCode == 17) {
                        var gap = time2 - time1;
                        time1 = time2;
                        if (gap < 500) {
                            if (show) {
                                $(".search-tool").css("display", "none");
                                show = false;
                            } else {
                                $(".search-tool").css("display", "block");
                                show = true;
                                $("#search-content").val("");
                                $("#search-content").focus();
                            }
                            time1 = 0;
                        }
                    } else if (e.keyCode == 27) {
                        $(".search-tool").css("display", "none");
                        show = false;
                        time1 = 0;
                    }
                });

                $("#search-content").keyup(function (e) {
                    var time2 = new Date().getTime();
                    if (window.event.keyCode == 17) {
                        var gap = time2 - time1;
                        time1 = time2;
                        if (gap < 500) {
                            if (show) {
                                $(".search-tool").css("display", "none");
                                show = false;
                            } else {
                                $(".search-tool").css("display", "block");
                                show = true;
                                $("#search-content").val("");
                                $("#search-content").focus();
                            }
                            time1 = 0;
                        }
                    }
                });

                $("#close-btn").click(function () {
                    $(".search-tool").css("display", "none");
                    show = false;
                    time1 = 0;
                });

                $("#search-btn").click(function () {
                    $(".search-tool").css("display", "block");
                    show = true;
                    $("#search-content").val("");
                    $("#search-content").focus();
                    time1 = 0;
                });
                // 家目录快捷键
                $(document).bind('keydown', 'alt+h', function () {
                    window.location.href = "/";
                });
                // 目录快捷键
                $(document).bind('keydown', 'alt+c', function () {
                    window.location.href = "/categories.html";
                });
                // 书单快捷键
                $(document).bind('keydown', 'alt+b', function () {
                    window.location.href = "/booklist.html";
                });
                // 个人介绍页快捷键
                $(document).bind('keydown', 'alt+a', function () {
                    window.location.href = "/about.html";
                });
                // 上一篇
                $(document).bind('keydown', 'alt+p', function () {
                    window.location.href = "/2016/07/10/hello_kafka";
                });
                // 下一篇
                $(document).bind('keydown', 'alt+n', function () {
                    window.location.href = "/2016/07/16/transaction";
                });

                $.getJSON("/search.json").done(function (data) {
                    if (data.code == 0) {
                        for (var index in data.data) {
                            var item = data.data[index];
                            names.push(item.title);
                            urls.push(item.url);
                        }

                        $("#search-content").typeahead({
                            source: names,

                            afterSelect: function (item) {
                                $(".search-tool").css("display", "none");
                                show = false;
                                window.location.href = (urls[names.indexOf(item)]);
                                return item;
                            }
                        });
                    }
                });

            });
        </script>

        <style>
            @media screen and (min-width: 768px) {
                .dropdown-menu {
                    float: none;
                    font-size: 20px;
                    width: 70%;
                    margin: 0 15%;
                }

                .search-tool ul {
                    width: 70%;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                .search-content {
                    width: 70%;
                    margin: 0 15%;
                    position: absolute;
                    top: 13%;
                    left: auto;
                    right: auto;
                    font-size: 22px;
                    height: 50px;
                    background-color: #eee;
                    color: black;
                    opacity: 1.0;
                }
            }

            @media screen and (max-width: 767px) {
                .dropdown-menu {
                    float: none;
                    font-size: 20px;
                    width: 96%;
                    margin: 0 2%;
                }

                .search-tool ul {
                    width: 96%;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                .search-content {
                    width: 96%;
                    margin: 0 2%;
                    position: absolute;
                    top: 10%;
                    left: auto;
                    right: auto;
                    font-size: 22px;
                    height: 50px;
                    background-color: #eee;
                    color: black;
                    opacity: 1.0;
                }
            }
        </style>
        <div class="search-tool" style="position: fixed; top: 0px ; bottom: 0px; left: 0px; right:  0px;
      opacity: 0.95; background-color: #111111; z-index: 9999; display: none;">
            <input type="text" class="form-control search-content" id="search-content" placeholder="文章标题 日期 标签">

            <div style="position: fixed; top: 16px; right: 16px;">
                <img src="/images/search/close.png" id="close-btn"/>
            </div>
        </div>

        <div style="position: fixed; right: 12px; top: 50%;bottom: 50%;">
            <img src="/images/search/search.png" id="search-btn" title="双击ctrl试一下"/>
        </div>

    </div>
</div>
</body>
</html>


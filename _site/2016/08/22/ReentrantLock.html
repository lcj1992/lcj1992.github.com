<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="baidu-site-verification" content="vuaTJrjFLn" />
    <meta name="keywords" content="foolchild,linux,java,技术,互联网" />
    <meta name="description" content="技术博客，记录foolchild技术道路上成长的点滴" />
    <title> ReentrantLock源码解析  </title>
    <link rel="stylesheet" href="/css/default.css" type="text/css"/>
    <link rel="stylesheet" href="/css/small.css" type="text/css" media="(max-width: 720px)"/>
    <link rel="stylesheet" href="/css/syntax.css" type="text/css"/>
    <link rel="stylesheet" href="/css/bootstrap.css" type="text/css"/>
    <link rel="stylesheet" href="/css/codeboy.css" type="text/css"/>
    <link rel="stylesheet" href="/css/donate.css" type="text/css"/>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"/>
</head>
<body>
<div id="container">
    <div class="nav">
    <div class="nav_nav">
        <a href="/">首页</a>
        <a href="/categories.html">目录</a>
        <a href="/booklist.html">书单</a>
        <a href="/about.html">关于</a>
    </div>
</div>

    <div id="main">
        <h2> ReentrantLock源码解析 </h2>
        <ul>
  <li><a href="#overview">概述</a></li>
  <li><a href="#nonFairLock">非公平锁</a>
    <ul>
      <li><a href="#ReentrantLock_lock">加锁过程</a>
        <ul>
          <li><a href="#NonfairLock_lock">NonfairLock#lock</a></li>
          <li><a href="#AQS_acquire">AQS#acquire</a></li>
          <li><a href="#Sync_nonfairTryAcquire">Sync#nonfairTryAcquire</a></li>
          <li><a href="#AQS_addWaiter">AQS#addWaiter</a></li>
          <li><a href="#AQS_enq">AQS#enq</a></li>
          <li><a href="#AQS_acquireQueued">AQS#acquireQueued</a></li>
          <li><a href="#AQS_shouldParkAfterFailedAcquire">AQS#shouldParkAfterFailedAcquire</a></li>
        </ul>
      </li>
      <li><a href="#ReentrantLock_unlock">解锁过程</a>
        <ul>
          <li><a href="#aqs_release">AbstractQueuedSynchronizer#release</a></li>
          <li><a href="#ReentrantLock_tryRelease">ReentrantLock#tryRelease</a></li>
          <li><a href="#AQS_acquireQueued">AQS#unparkSuccessor</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#FairLock">公平锁</a>
    <ul>
      <li><a href="#ReentrantLock_lock_fair">加锁过程</a>
        <ul>
          <li><a href="#FairLock_lock">FairLock#lock</a></li>
          <li><a href="#FairSync_tryAcquire">FairSync#tryAcquire</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="overview">概述</h2>

<p>ReentrantLock的结构体如下</p>

<p><img src="/images/java/reentrantLock.png" alt="reentrantLock" /></p>

<ol>
  <li>内部类<code class="highlighter-rouge">Sync</code>继承自<code class="highlighter-rouge">AbstractQueuedSynchronizer</code> 参见<a href="/2016/08/24/aqs">aqs</a></li>
  <li>Sync两个子类 <code class="highlighter-rouge">NonfairSync</code>实现非公平锁、<code class="highlighter-rouge">FairSync</code>实现公平锁</li>
  <li>使用AQS的独占API</li>
</ol>

<h2 id="nonFairLock">非公平锁</h2>

<p>idea debug多线程，将断点设置为线程级别就可以了,如下图所示
<img src="/images/java/multi_thread_debug.png" alt="多线程debug" /></p>

<p>然后在debug时，在这里切换线程
<img src="/images/java/switch_thread.png" alt="切换线程" /></p>

<p>设置以下几个断点
<img src="/images/java/break_points.png" alt="断点位置" /></p>

<p>本文使用的例子</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// 1.线程1首先拿到锁，但不释放锁呢。
// 2.线程2，3，4依次入等待队列
// 3.线程4自旋一次，会将pred的waitStatus改为signal，观察线程3释放锁时的unparkSuccessor操作。
@Test
public void howToLockTest() throws InterruptedException {
    ReentrantLock lock = new ReentrantLock();
    new Thread(new MyRunnable(lock), "thread1").start();
    Thread.sleep(100);
    new Thread(new MyRunnable(lock), "thread2").start();
    new Thread(new MyRunnable(lock), "thread3").start();
    new Thread(new MyRunnable(lock), "thread4").start();
    Thread.sleep(1000000000);
}

private class MyRunnable implements Runnable {
    private ReentrantLock lock;

    MyRunnable(ReentrantLock lock) {
        this.lock = lock;
    }

    @Override
    public void run() {
        lock.lock();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
</div>

<h3 id="ReentrantLock_lock">加锁过程</h3>

<h4 id="NonfairLock_lock">NonfairLock#lock</h4>

<p>ReentrantLock#lock() -&gt; NonfairLock#lock()</p>

<div class="highlighter-rouge"><pre class="highlight"><code> // 执行加锁，立即闯入，如果失败的话执行正常的acquire
final void lock() {
    // CAS操作保证操作的原子性
    // state声明为 volatile保证内存可见性,state=0表明可以争用。
    // 非公平的，刚进来就大家随便争，可以对比下公平锁的lock这里怎么搞的。
    if (compareAndSetState(0, 1))
        // 如果state 0-&gt;1设置成功,设置当前线程为同步器的属主线程
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
</code></pre>
</div>

<p>线程1因为比线程2，3，4执行提前0.1s，所以肯定走不到else分支，
因为线程1拿到锁之后并不释放锁，所以线程2，3，4肯定走else分支，acquire(1)</p>

<h4 id="AQS_acquire">AQS#acquire</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>// 尝试获取锁，获取不到则创建一个waiter（当前线程）后放到队列中
public final void acquire(int arg) {
    // 以独占模式acquire失败
    if (!tryAcquire(arg) &amp;&amp;
    // 包装一个当前线程的Node，入队列，然后尝试去acquire
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        // 如果该线程被中断了，中断当前线程
        selfInterrupt();
}
</code></pre>
</div>

<h4 id="Sync_nonfairTryAcquire">Sync#nonfairTryAcquire</h4>

<p>NonfairSync#tryAcquire(arg) -&gt; Sync#nonfairTryAcquire(arg)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    // 获取state标志位，如果为0，没有线程持有锁
    if (c == 0) {
        // CAS尝试去获取锁。
        if (compareAndSetState(0, acquires)) {
            // 如果获取成功，设置属主线程为当前线程。
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 如果不为0，判断当前线程是否为属主线程，这里实现可重入
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0) // overflow
            throw new Error("Maximum lock count exceeded");
        // 设置state的值，state的值表明当前线程的重入数。
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
</div>

<p>如果tryAcquire失败，把当前线程包装为一个Node入队列，并再次尝试acquire</p>

<p>包装当前线程为一个node</p>

<h4 id="AQS_addWaiter">AQS#addWaiter</h4>

<p>AbstractQueuedSynchronizer#addWaiter()</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private Node addWaiter(Node mode) {
   Node node = new Node(Thread.currentThread(), mode);
   // Try the fast path of enq; backup to full enq on failure
   Node pred = tail;
   // 如果队列不为空
   if (pred != null) {
       // node的先驱节点设置为tail
       node.prev = pred;
       // 设置当前节点为tail
       if (compareAndSetTail(pred, node)) {
           // 原有的tail的后继节点指向node
           pred.next = node;
           return node;
       }
   }
   // 如果pred为null，说明之前队列为空，执行enq方法，自旋方式入队列
   // 或者设置当前节点为tail失败，表明有别的线程并发入队列，执行enq方法，自旋方式入队列。
   enq(node);
   return node;    }
</code></pre>
</div>

<h4 id="AQS_enq">AQS#enq</h4>

<p>AbstractQueuedSynchronizer#enq()</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private Node enq(final Node node) {
    // 自旋方式入队列
    for (;;) {
        Node t = tail;
        // !!!!重要
        // 如果队列为空，初始化head和tail节点
        if (t == null) { // Must initialize
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // 如果队列不为空，将该节点的前驱节点设置为tail，
            node.prev = t;
            // 同时cas设置tail为node，如果设置失败，说明有并发修改tail
            if (compareAndSetTail(t, node)) {
                // 设置tail的后继节点为node
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>
</div>

<p>入队列后，然后尝试从队列中acquire</p>

<h4 id="AQS_acquireQueued">AQS#acquireQueued</h4>

<p>AbstractQueuedSynchronizer#acquireQueued()</p>

<div class="highlighter-rouge"><pre class="highlight"><code>final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            // 如果先驱节点为head，尝试acquire
            if (p == head &amp;&amp; tryAcquire(arg)) {
                // acquire成功，将head节点置为node
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            // 如果先驱节点不是head，或者是head，但是尝试acquire失败
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
</div>

<p>AbstractQueuedSynchronizer#setHead()</p>

<div class="highlighter-rouge"><pre class="highlight"><code>private void setHead(Node node) {
    head = node;
    // 头节点不绑定线程
    node.thread = null;
    node.prev = null;
}
</code></pre>
</div>

<h4 id="AQS_shouldParkAfterFailedAcquire">AQS#shouldParkAfterFailedAcquire</h4>

<div class="highlighter-rouge"><pre class="highlight"><code> /** waitStatus value to indicate thread has cancelled */
 // 当前线程已经被取消
 static final int CANCELLED =  1;
 /** waitStatus value to indicate successor's thread needs unparking */
 // 后继节点线程等待被触发
 static final int SIGNAL    = -1;
 /** waitStatus value to indicate thread is waiting on condition */
 // 线程等待条件
 static final int CONDITION = -2;
 /**
  * waitStatus value to indicate the next acquireShared should
  * unconditionally propagate
  */
 // 节点状态需要向后传播
 static final int PROPAGATE = -3;

private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
        // 只有当前节点的前一个节点为SIGNAL时，当前节点才能被挂起
        return true;
    if (ws &gt; 0) {
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don't park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>
</div>

<h3 id="ReentrantLock_unlock">解锁过程</h3>

<p>解锁过程较简单点</p>

<h4 id="aqs_release">AbstractQueuedSynchronizer#release</h4>

<p>ReentrantLock#unlock() -&gt; AbstractQueuedSynchronizer#release()</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        // 属主线程可能是head节点也可能不是head节点哟。
        if (h != null &amp;&amp; h.waitStatus != 0)
            // 如果是head节点，并且waitStatus不为0(SIGNAL、CONDITION、PROPAGATE）,则唤醒后继节点。
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>
</div>

<h4 id="ReentrantLock_tryRelease">ReentrantLock#tryRelease</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    // 可重入，只有减为0时，才是free，别的线程才能抢得到。
    if (c == 0) {
        free = true;
        // 设置属主线程为null
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>
</div>

<h4 id="aqs_unparkSuccessor">AQS#unparkSuccessor</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>    private void unparkSuccessor(Node node) {
   /*
    * If status is negative (i.e., possibly needing signal) try
    * to clear in anticipation of signalling.  It is OK if this
    * fails or if status is changed by waiting thread.
    */
   // 如果状态是负的（例如，可能等待着被signal）
   int ws = node.waitStatus;
   if (ws &lt; 0)
       compareAndSetWaitStatus(node, ws, 0);

   /*
    * Thread to unpark is held in successor, which is normally
    * just the next node.  But if cancelled or apparently null,
    * traverse backwards from tail to find the actual
    * non-cancelled successor.
    */
   Node s = node.next;
   if (s == null || s.waitStatus &gt; 0) {
       s = null;
       for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
           if (t.waitStatus &lt;= 0)
               s = t;
   }
   if (s != null)
       LockSupport.unpark(s.thread);    }
</code></pre>
</div>

<h2 id="FairLock">公平锁</h2>

<h3 id="ReentrantLock_lock_fair">加锁过程</h3>

<p>整体流程和非公平加锁是一样的。</p>

<h4 id="FairLock_lock">FairLock#lock</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>final void lock() {
    // if (compareAndSetState(0, 1))
    //    setExclusiveOwnerThread(Thread.currentThread());
    // else
    // 必须严格按照队列顺序来
    acquire(1);
}
</code></pre>
</div>

<h4 id="FairSync_tryAcquire">FairSync#tryAcquire</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // 比非公平加锁，多了这个判定条件 hasQueuedPredecessors，必须没有前驱节点才让你acquire，否则的话，好好等着，轮到你再来。
        if (!hasQueuedPredecessors() &amp;&amp;
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
</div>

<p>解锁过程和非公平锁是一样一样的。</p>

<h2 id="ref">参考</h2>

<p>[x86的指令集]<a href="http://www.felixcloutier.com/x86/">http://www.felixcloutier.com/x86/</a></p>

<p>[AQS,老爷子的论文]<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf">http://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></p>

<p>[AbstractQueuedSynchronizer的实现分析（上）]<a href="http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer">http://www.infoq.com/cn/articles/jdk1.8-abstractqueuedsynchronizer</a></p>

<p>[AbstractQueuedSynchronizer的实现分析（下）]<a href="http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer">http://www.infoq.com/cn/articles/java8-abstractqueuedsynchronizer</a></p>

        <ul class="prev_next">
            
            <li>
                <span>上一篇</span>
                <a href="/2016/08/06/jvm_compile">如何得到jvm的本地指令</a>
            </li>
            
            
            <li>
                <span>下一篇</span>
                <a href="/2016/08/24/aqs">AbstractQueuedSynchronizer</a>
            </li>
            
        </ul>

        <!-- 多说评论 -->
        <div class="ds-share flat" data-thread-key="/2016/08/22/ReentrantLock" data-title="ReentrantLock源码解析"
             data-url="http://lcj1992.github.io/2016/08/22/ReentrantLock">
            <div class="ds-share-inline">
                <ul class="ds-share-icons-16">

                    <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
                    <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
                    <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

                </ul>
                <div class="ds-share-icons-more">
                </div>
            </div>
        </div>
        <!-- 打赏 -->
        <div class="post-donate">
            <div id="donate_board" class="donate_bar center hidden">
                <a id="btn_donate" href="javascript:;" title="打赏" class="btn_donate"></a>
                <div class="donate_txt"> ↑<br>此文有用? 求鼓励!<br></div>
            </div>
            <div id="donate_guide" class="donate_bar center">
                <a href="/images/donate.jpg" title="此文有用? 求鼓励!" class="fancybox" rel="gallery">
                    <img src="/images/donate.jpg" title="微信打赏"></a>
            </div>
            <script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
                $('#donate_board').addClass('hidden');
                $('#donate_guide').removeClass('hidden');
            }
            </script>
        </div>
        <div class="ds-thread" data-thread-key="/2016/08/22/ReentrantLock" data-title="ReentrantLock源码解析"
             data-url="http://lcj1992.github.io/2016/08/22/ReentrantLock"></div>
        <!-- 多说评论框 end -->
        <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
        <script type="text/javascript">
            var duoshuoQuery = {short_name: "lcj1992"};
            (function () {
                var ds = document.createElement('script');
                ds.type = 'text/javascript';
                ds.async = true;
                ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                ds.charset = 'UTF-8';
                (document.getElementsByTagName('head')[0]
                || document.getElementsByTagName('body')[0]).appendChild(ds);
            })();
        </script>

        <!-- jQuery -->
        <script src="/js/jquery.js"></script>

        <!-- Bootstrap Core JavaScript -->
        <script src="/js/bootstrap.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="/js/codeboy.js"></script>

        <script src="/js/bootstrap3-typeahead.js"></script>
        <script src="/js/jquery.hotkeys.js"></script>
        <script>
            (function (i, s, o, g, r, a, m) {
                i['GoogleAnalyticsObject'] = r;
                i[r] = i[r] || function () {
                            (i[r].q = i[r].q || []).push(arguments)
                        }, i[r].l = 1 * new Date();
                a = s.createElement(o),
                        m = s.getElementsByTagName(o)[0];
                a.async = 1;
                a.src = g;
                m.parentNode.insertBefore(a, m)
            })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

            ga('create', 'UA-72949519-1', 'auto');
            ga('send', 'pageview');

        </script>

        <!-- TODO: only load in tag.html -->
        <script src="/js/jquery.tagcloud.js" type="text/javascript" charset="utf-8"></script>
        <script language="javascript">
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'}
            };
            $(function () {
                $('#tag_cloud a').tagcloud();
            });
        </script>

        <!-- async load function -->
        <script>
            function async(u, c) {
                var d = document, t = 'script',
                        o = d.createElement(t),
                        s = d.getElementsByTagName(t)[0];
                o.src = u;
                if (c) {
                    o.addEventListener('load', function (e) {
                        c(null, e);
                    }, false);
                }
                s.parentNode.insertBefore(o, s);
            }
        </script>

        <!-- Highlight.js -->
        <script>
            async("https://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () {
                hljs.initHighlightingOnLoad();
            })
        </script>
        <link href="https://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">


        <script>
            $(document).ready(function () {
                var time1 = 0;
                var show = false;
                var names = new Array(); //文章名字等
                var urls = new Array(); //文章地址
                $(document).keyup(function (e) {
                    var time2 = new Date().getTime();
                    if (e.keyCode == 17) {
                        var gap = time2 - time1;
                        time1 = time2;
                        if (gap < 500) {
                            if (show) {
                                $(".search-tool").css("display", "none");
                                show = false;
                            } else {
                                $(".search-tool").css("display", "block");
                                show = true;
                                $("#search-content").val("");
                                $("#search-content").focus();
                            }
                            time1 = 0;
                        }
                    } else if (e.keyCode == 27) {
                        $(".search-tool").css("display", "none");
                        show = false;
                        time1 = 0;
                    }
                });

                $("#search-content").keyup(function (e) {
                    var time2 = new Date().getTime();
                    if (window.event.keyCode == 17) {
                        var gap = time2 - time1;
                        time1 = time2;
                        if (gap < 500) {
                            if (show) {
                                $(".search-tool").css("display", "none");
                                show = false;
                            } else {
                                $(".search-tool").css("display", "block");
                                show = true;
                                $("#search-content").val("");
                                $("#search-content").focus();
                            }
                            time1 = 0;
                        }
                    }
                });

                $("#close-btn").click(function () {
                    $(".search-tool").css("display", "none");
                    show = false;
                    time1 = 0;
                });

                $("#search-btn").click(function () {
                    $(".search-tool").css("display", "block");
                    show = true;
                    $("#search-content").val("");
                    $("#search-content").focus();
                    time1 = 0;
                });
                // 家目录快捷键
                $(document).bind('keydown', 'alt+h', function () {
                    window.location.href = "/";
                });
                // 目录快捷键
                $(document).bind('keydown', 'alt+c', function () {
                    window.location.href = "/categories.html";
                });
                // 书单快捷键
                $(document).bind('keydown', 'alt+b', function () {
                    window.location.href = "/booklist.html";
                });
                // 个人介绍页快捷键
                $(document).bind('keydown', 'alt+a', function () {
                    window.location.href = "/about.html";
                });
                // 上一篇
                $(document).bind('keydown', 'alt+p', function () {
                    window.location.href = "/2016/08/06/jvm_compile";
                });
                // 下一篇
                $(document).bind('keydown', 'alt+n', function () {
                    window.location.href = "/2016/08/24/aqs";
                });

                $.getJSON("/search.json").done(function (data) {
                    if (data.code == 0) {
                        for (var index in data.data) {
                            var item = data.data[index];
                            names.push(item.title);
                            urls.push(item.url);
                        }

                        $("#search-content").typeahead({
                            source: names,

                            afterSelect: function (item) {
                                $(".search-tool").css("display", "none");
                                show = false;
                                window.location.href = (urls[names.indexOf(item)]);
                                return item;
                            }
                        });
                    }
                });

            });
        </script>

        <style>
            @media screen and (min-width: 768px) {
                .dropdown-menu {
                    float: none;
                    font-size: 20px;
                    width: 70%;
                    margin: 0 15%;
                }

                .search-tool ul {
                    width: 70%;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                .search-content {
                    width: 70%;
                    margin: 0 15%;
                    position: absolute;
                    top: 13%;
                    left: auto;
                    right: auto;
                    font-size: 22px;
                    height: 50px;
                    background-color: #eee;
                    color: black;
                    opacity: 1.0;
                }
            }

            @media screen and (max-width: 767px) {
                .dropdown-menu {
                    float: none;
                    font-size: 20px;
                    width: 96%;
                    margin: 0 2%;
                }

                .search-tool ul {
                    width: 96%;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }

                .search-content {
                    width: 96%;
                    margin: 0 2%;
                    position: absolute;
                    top: 10%;
                    left: auto;
                    right: auto;
                    font-size: 22px;
                    height: 50px;
                    background-color: #eee;
                    color: black;
                    opacity: 1.0;
                }
            }
        </style>
        <div class="search-tool" style="position: fixed; top: 0px ; bottom: 0px; left: 0px; right:  0px;
      opacity: 0.95; background-color: #111111; z-index: 9999; display: none;">
            <input type="text" class="form-control search-content" id="search-content" placeholder="文章标题 日期 标签">

            <div style="position: fixed; top: 16px; right: 16px;">
                <img src="/images/search/close.png" id="close-btn"/>
            </div>
        </div>

        <div style="position: fixed; right: 12px; top: 50%;bottom: 50%;">
            <img src="/images/search/search.png" id="search-btn" title="双击ctrl试一下"/>
        </div>

    </div>
</div>
</body>
</html>
